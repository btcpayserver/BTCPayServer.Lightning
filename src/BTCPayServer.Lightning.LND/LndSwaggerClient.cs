//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.1.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace BTCPayServer.Lightning.LND
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.4.1.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class LndSwaggerClient
    {
        private string _baseUrl = "http://";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public LndSwaggerClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }
    
        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>* lncli: `walletbalance`
        /// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
        /// confirmed unspent outputs and all unconfirmed unspent outputs under control
        /// of the wallet.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcWalletBalanceResponse> WalletBalanceAsync()
        {
            return WalletBalanceAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `walletbalance`
        /// WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
        /// confirmed unspent outputs and all unconfirmed unspent outputs under control
        /// of the wallet.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcWalletBalanceResponse> WalletBalanceAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/balance/blockchain");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcWalletBalanceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcWalletBalanceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `channelbalance`
        /// ChannelBalance returns the total funds available across all open channels
        /// in satoshis.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChannelBalanceResponse> ChannelBalanceAsync()
        {
            return ChannelBalanceAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `channelbalance`
        /// ChannelBalance returns the total funds available across all open channels
        /// in satoshis.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChannelBalanceResponse> ChannelBalanceAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/balance/channels");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChannelBalanceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChannelBalanceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `changepassword`
        /// ChangePassword changes the password of the encrypted wallet. This will
        /// automatically unlock the wallet database if successful.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChangePasswordResponse> ChangePasswordAsync(LnrpcChangePasswordRequest body)
        {
            return ChangePasswordAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `changepassword`
        /// ChangePassword changes the password of the encrypted wallet. This will
        /// automatically unlock the wallet database if successful.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChangePasswordResponse> ChangePasswordAsync(LnrpcChangePasswordRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/changepassword");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChangePasswordResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChangePasswordResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listchannels`
        /// ListChannels returns a description of all the open channels that this node
        /// is a participant in.</summary>
        /// <param name="peer">*
        /// Filters the response for channels with a target peer's pubkey. If peer is
        /// empty, all channels will be returned.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcListChannelsResponse> ListChannelsAsync(bool? active_only, bool? inactive_only, bool? public_only, bool? private_only, byte[] peer)
        {
            return ListChannelsAsync(active_only, inactive_only, public_only, private_only, peer, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listchannels`
        /// ListChannels returns a description of all the open channels that this node
        /// is a participant in.</summary>
        /// <param name="peer">*
        /// Filters the response for channels with a target peer's pubkey. If peer is
        /// empty, all channels will be returned.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcListChannelsResponse> ListChannelsAsync(bool? active_only, bool? inactive_only, bool? public_only, bool? private_only, byte[] peer, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels?");
            if (active_only != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("active_only") + "=").Append(System.Uri.EscapeDataString(ConvertToString(active_only, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (inactive_only != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("inactive_only") + "=").Append(System.Uri.EscapeDataString(ConvertToString(inactive_only, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (public_only != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("public_only") + "=").Append(System.Uri.EscapeDataString(ConvertToString(public_only, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (private_only != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("private_only") + "=").Append(System.Uri.EscapeDataString(ConvertToString(private_only, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (peer != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("peer") + "=").Append(System.Uri.EscapeDataString(ConvertToString(peer, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcListChannelsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcListChannelsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
        /// call is meant to be consumed by clients to the REST proxy. As with all
        /// other sync calls, all byte slices are intended to be populated as hex
        /// encoded strings.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChannelPoint> OpenChannelSyncAsync(LnrpcOpenChannelRequest body)
        {
            return OpenChannelSyncAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
        /// call is meant to be consumed by clients to the REST proxy. As with all
        /// other sync calls, all byte slices are intended to be populated as hex
        /// encoded strings.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChannelPoint> OpenChannelSyncAsync(LnrpcOpenChannelRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChannelPoint>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChannelPoint);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `abandonchannel`
        /// AbandonChannel removes all channel state from the database except for a
        /// close summary. This method can be used to get rid of permanently unusable
        /// channels due to bugs fixed in newer versions of lnd. Only available
        /// when in debug builds of lnd.</summary>
        /// <param name="channel_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="channel_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="channel_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcAbandonChannelResponse> AbandonChannelAsync(string channel_point_funding_txid_str, long channel_point_output_index, byte[] channel_point_funding_txid_bytes)
        {
            return AbandonChannelAsync(channel_point_funding_txid_str, channel_point_output_index, channel_point_funding_txid_bytes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `abandonchannel`
        /// AbandonChannel removes all channel state from the database except for a
        /// close summary. This method can be used to get rid of permanently unusable
        /// channels due to bugs fixed in newer versions of lnd. Only available
        /// when in debug builds of lnd.</summary>
        /// <param name="channel_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="channel_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="channel_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcAbandonChannelResponse> AbandonChannelAsync(string channel_point_funding_txid_str, long channel_point_output_index, byte[] channel_point_funding_txid_bytes, System.Threading.CancellationToken cancellationToken)
        {
            if (channel_point_funding_txid_str == null)
                throw new System.ArgumentNullException("channel_point_funding_txid_str");
    
            if (channel_point_output_index == null)
                throw new System.ArgumentNullException("channel_point_output_index");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/abandon/{channel_point.funding_txid_str}/{channel_point.output_index}?");
            urlBuilder_.Replace("{channel_point.funding_txid_str}", System.Uri.EscapeDataString(ConvertToString(channel_point_funding_txid_str, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{channel_point.output_index}", System.Uri.EscapeDataString(ConvertToString(channel_point_output_index, System.Globalization.CultureInfo.InvariantCulture)));
            if (channel_point_funding_txid_bytes != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("channel_point.funding_txid_bytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(channel_point_funding_txid_bytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcAbandonChannelResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcAbandonChannelResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// ExportAllChannelBackups returns static channel backups for all existing
        /// channels known to lnd. A set of regular singular static channel backups for
        /// each channel are returned. Additionally, a multi-channel backup is returned
        /// as well, which contains a single encrypted blob containing the backups of
        /// each channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChanBackupSnapshot> ExportAllChannelBackupsAsync()
        {
            return ExportAllChannelBackupsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// ExportAllChannelBackups returns static channel backups for all existing
        /// channels known to lnd. A set of regular singular static channel backups for
        /// each channel are returned. Additionally, a multi-channel backup is returned
        /// as well, which contains a single encrypted blob containing the backups of
        /// each channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChanBackupSnapshot> ExportAllChannelBackupsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/backup");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChanBackupSnapshot>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChanBackupSnapshot);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `restorechanbackup`
        /// RestoreChannelBackups accepts a set of singular channel backups, or a
        /// single encrypted multi-chan backup and attempts to recover any funds
        /// remaining within the channel. If we are able to unpack the backup, then the
        /// new channel will be shown under listchannels, as well as pending channels.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcRestoreBackupResponse> RestoreChannelBackupsAsync(LnrpcRestoreChanBackupRequest body)
        {
            return RestoreChannelBackupsAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `restorechanbackup`
        /// RestoreChannelBackups accepts a set of singular channel backups, or a
        /// single encrypted multi-chan backup and attempts to recover any funds
        /// remaining within the channel. If we are able to unpack the backup, then the
        /// new channel will be shown under listchannels, as well as pending channels.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcRestoreBackupResponse> RestoreChannelBackupsAsync(LnrpcRestoreChanBackupRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/backup/restore");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcRestoreBackupResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcRestoreBackupResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// VerifyChanBackup allows a caller to verify the integrity of a channel backup
        /// snapshot. This method will accept either a packed Single or a packed Multi.
        /// Specifying both will result in an error.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcVerifyChanBackupResponse> VerifyChanBackupAsync(LnrpcChanBackupSnapshot body)
        {
            return VerifyChanBackupAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// VerifyChanBackup allows a caller to verify the integrity of a channel backup
        /// snapshot. This method will accept either a packed Single or a packed Multi.
        /// Specifying both will result in an error.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcVerifyChanBackupResponse> VerifyChanBackupAsync(LnrpcChanBackupSnapshot body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/backup/verify");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcVerifyChanBackupResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcVerifyChanBackupResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `exportchanbackup`
        /// ExportChannelBackup attempts to return an encrypted static channel backup
        /// for the target channel identified by it channel point. The backup is
        /// encrypted with a key generated from the aezeed seed of the user. The
        /// returned backup can either be restored using the RestoreChannelBackup
        /// method once lnd is running, or via the InitWallet and UnlockWallet methods
        /// from the WalletUnlocker service.</summary>
        /// <param name="chan_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="chan_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="chan_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChannelBackup> ExportChannelBackupAsync(string chan_point_funding_txid_str, long chan_point_output_index, byte[] chan_point_funding_txid_bytes)
        {
            return ExportChannelBackupAsync(chan_point_funding_txid_str, chan_point_output_index, chan_point_funding_txid_bytes, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `exportchanbackup`
        /// ExportChannelBackup attempts to return an encrypted static channel backup
        /// for the target channel identified by it channel point. The backup is
        /// encrypted with a key generated from the aezeed seed of the user. The
        /// returned backup can either be restored using the RestoreChannelBackup
        /// method once lnd is running, or via the InitWallet and UnlockWallet methods
        /// from the WalletUnlocker service.</summary>
        /// <param name="chan_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="chan_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="chan_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChannelBackup> ExportChannelBackupAsync(string chan_point_funding_txid_str, long chan_point_output_index, byte[] chan_point_funding_txid_bytes, System.Threading.CancellationToken cancellationToken)
        {
            if (chan_point_funding_txid_str == null)
                throw new System.ArgumentNullException("chan_point_funding_txid_str");
    
            if (chan_point_output_index == null)
                throw new System.ArgumentNullException("chan_point_output_index");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/backup/{chan_point.funding_txid_str}/{chan_point.output_index}?");
            urlBuilder_.Replace("{chan_point.funding_txid_str}", System.Uri.EscapeDataString(ConvertToString(chan_point_funding_txid_str, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{chan_point.output_index}", System.Uri.EscapeDataString(ConvertToString(chan_point_output_index, System.Globalization.CultureInfo.InvariantCulture)));
            if (chan_point_funding_txid_bytes != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("chan_point.funding_txid_bytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(chan_point_funding_txid_bytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChannelBackup>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChannelBackup);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `closedchannels`
        /// ClosedChannels returns a description of all the closed channels that
        /// this node was a participant in.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcClosedChannelsResponse> ClosedChannelsAsync(bool? cooperative, bool? local_force, bool? remote_force, bool? breach, bool? funding_canceled, bool? abandoned)
        {
            return ClosedChannelsAsync(cooperative, local_force, remote_force, breach, funding_canceled, abandoned, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `closedchannels`
        /// ClosedChannels returns a description of all the closed channels that
        /// this node was a participant in.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcClosedChannelsResponse> ClosedChannelsAsync(bool? cooperative, bool? local_force, bool? remote_force, bool? breach, bool? funding_canceled, bool? abandoned, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/closed?");
            if (cooperative != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("cooperative") + "=").Append(System.Uri.EscapeDataString(ConvertToString(cooperative, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (local_force != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("local_force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(local_force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (remote_force != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("remote_force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(remote_force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (breach != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("breach") + "=").Append(System.Uri.EscapeDataString(ConvertToString(breach, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (funding_canceled != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("funding_canceled") + "=").Append(System.Uri.EscapeDataString(ConvertToString(funding_canceled, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (abandoned != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("abandoned") + "=").Append(System.Uri.EscapeDataString(ConvertToString(abandoned, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcClosedChannelsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcClosedChannelsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `pendingchannels`
        /// PendingChannels returns a list of all the channels that are currently
        /// considered "pending". A channel is pending if it has finished the funding
        /// workflow and is waiting for confirmations for the funding txn, or is in the
        /// process of closure, either initiated cooperatively or non-cooperatively.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcPendingChannelsResponse> PendingChannelsAsync()
        {
            return PendingChannelsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `pendingchannels`
        /// PendingChannels returns a list of all the channels that are currently
        /// considered "pending". A channel is pending if it has finished the funding
        /// workflow and is waiting for confirmations for the funding txn, or is in the
        /// process of closure, either initiated cooperatively or non-cooperatively.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcPendingChannelsResponse> PendingChannelsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/pending");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcPendingChannelsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcPendingChannelsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// SendPaymentSync is the synchronous non-streaming version of SendPayment.
        /// This RPC is intended to be consumed by clients of the REST proxy.
        /// Additionally, this RPC expects the destination's public key and the payment
        /// hash (if any) to be encoded as hex strings.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcSendResponse> SendPaymentSyncAsync(LnrpcSendRequest body)
        {
            return SendPaymentSyncAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// SendPaymentSync is the synchronous non-streaming version of SendPayment.
        /// This RPC is intended to be consumed by clients of the REST proxy.
        /// Additionally, this RPC expects the destination's public key and the payment
        /// hash (if any) to be encoded as hex strings.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcSendResponse> SendPaymentSyncAsync(LnrpcSendRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/transactions");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcSendResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcSendResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// SendToRouteSync is a synchronous version of SendToRoute. It Will block
        /// until the payment either fails or succeeds.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcSendResponse> SendToRouteSyncAsync(LnrpcSendToRouteRequest body)
        {
            return SendToRouteSyncAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// SendToRouteSync is a synchronous version of SendToRoute. It Will block
        /// until the payment either fails or succeeds.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcSendResponse> SendToRouteSyncAsync(LnrpcSendToRouteRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/transactions/route");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcSendResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcSendResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `closechannel`
        /// CloseChannel attempts to close an active channel identified by its channel
        /// outpoint (ChannelPoint). The actions of this method can additionally be
        /// augmented to attempt a force close after a timeout period in the case of an
        /// inactive peer. If a non-force close (cooperative closure) is requested,
        /// then the user can specify either a target number of blocks until the
        /// closure transaction is confirmed, or a manual fee rate. If neither are
        /// specified, then a default lax, block confirmation target is used.</summary>
        /// <param name="channel_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="channel_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="channel_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <param name="force">/ If true, then the channel will be closed forcibly. This means the
        /// / current commitment transaction will be signed and broadcast.</param>
        /// <param name="target_conf">/ The target number of blocks that the closure transaction should be
        /// / confirmed by.</param>
        /// <param name="sat_per_byte">/ A manual fee rate set in sat/byte that should be used when crafting the
        /// / closure transaction.</param>
        /// <param name="delivery_address">An optional address to send funds to in the case of a cooperative close.
        /// If the channel was opened with an upfront shutdown script and this field
        /// is set, the request to close will fail because the channel must pay out
        /// to the upfront shutdown addresss.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Response> CloseChannelAsync(string channel_point_funding_txid_str, long channel_point_output_index, byte[] channel_point_funding_txid_bytes, bool? force, int? target_conf, string sat_per_byte, string delivery_address)
        {
            return CloseChannelAsync(channel_point_funding_txid_str, channel_point_output_index, channel_point_funding_txid_bytes, force, target_conf, sat_per_byte, delivery_address, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `closechannel`
        /// CloseChannel attempts to close an active channel identified by its channel
        /// outpoint (ChannelPoint). The actions of this method can additionally be
        /// augmented to attempt a force close after a timeout period in the case of an
        /// inactive peer. If a non-force close (cooperative closure) is requested,
        /// then the user can specify either a target number of blocks until the
        /// closure transaction is confirmed, or a manual fee rate. If neither are
        /// specified, then a default lax, block confirmation target is used.</summary>
        /// <param name="channel_point_funding_txid_str">*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</param>
        /// <param name="channel_point_output_index">/ The index of the output of the funding transaction</param>
        /// <param name="channel_point_funding_txid_bytes">*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</param>
        /// <param name="force">/ If true, then the channel will be closed forcibly. This means the
        /// / current commitment transaction will be signed and broadcast.</param>
        /// <param name="target_conf">/ The target number of blocks that the closure transaction should be
        /// / confirmed by.</param>
        /// <param name="sat_per_byte">/ A manual fee rate set in sat/byte that should be used when crafting the
        /// / closure transaction.</param>
        /// <param name="delivery_address">An optional address to send funds to in the case of a cooperative close.
        /// If the channel was opened with an upfront shutdown script and this field
        /// is set, the request to close will fail because the channel must pay out
        /// to the upfront shutdown addresss.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Response> CloseChannelAsync(string channel_point_funding_txid_str, long channel_point_output_index, byte[] channel_point_funding_txid_bytes, bool? force, int? target_conf, string sat_per_byte, string delivery_address, System.Threading.CancellationToken cancellationToken)
        {
            if (channel_point_funding_txid_str == null)
                throw new System.ArgumentNullException("channel_point_funding_txid_str");
    
            if (channel_point_output_index == null)
                throw new System.ArgumentNullException("channel_point_output_index");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/channels/{channel_point.funding_txid_str}/{channel_point.output_index}?");
            urlBuilder_.Replace("{channel_point.funding_txid_str}", System.Uri.EscapeDataString(ConvertToString(channel_point_funding_txid_str, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{channel_point.output_index}", System.Uri.EscapeDataString(ConvertToString(channel_point_output_index, System.Globalization.CultureInfo.InvariantCulture)));
            if (channel_point_funding_txid_bytes != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("channel_point.funding_txid_bytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(channel_point_funding_txid_bytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (force != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("force") + "=").Append(System.Uri.EscapeDataString(ConvertToString(force, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (target_conf != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("target_conf") + "=").Append(System.Uri.EscapeDataString(ConvertToString(target_conf, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (sat_per_byte != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("sat_per_byte") + "=").Append(System.Uri.EscapeDataString(ConvertToString(sat_per_byte, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (delivery_address != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("delivery_address") + "=").Append(System.Uri.EscapeDataString(ConvertToString(delivery_address, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Response);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `updatechanpolicy`
        /// UpdateChannelPolicy allows the caller to update the fee schedule and
        /// channel policies for all channels globally, or a particular channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcPolicyUpdateResponse> UpdateChannelPolicyAsync(LnrpcPolicyUpdateRequest body)
        {
            return UpdateChannelPolicyAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `updatechanpolicy`
        /// UpdateChannelPolicy allows the caller to update the fee schedule and
        /// channel policies for all channels globally, or a particular channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcPolicyUpdateResponse> UpdateChannelPolicyAsync(LnrpcPolicyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/chanpolicy");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcPolicyUpdateResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcPolicyUpdateResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `feereport`
        /// FeeReport allows the caller to obtain a report detailing the current fee
        /// schedule enforced by the node globally for each channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcFeeReportResponse> FeeReportAsync()
        {
            return FeeReportAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `feereport`
        /// FeeReport allows the caller to obtain a report detailing the current fee
        /// schedule enforced by the node globally for each channel.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcFeeReportResponse> FeeReportAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fees");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcFeeReportResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcFeeReportResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// GenSeed is the first method that should be used to instantiate a new lnd
        /// instance. This method allows a caller to generate a new aezeed cipher seed
        /// given an optional passphrase. If provided, the passphrase will be necessary
        /// to decrypt the cipherseed to expose the internal wallet seed.</summary>
        /// <param name="aezeed_passphrase">*
        /// aezeed_passphrase is an optional user provided passphrase that will be used
        /// to encrypt the generated aezeed cipher seed. When using REST, this field
        /// must be encoded as base64.</param>
        /// <param name="seed_entropy">*
        /// seed_entropy is an optional 16-bytes generated via CSPRNG. If not
        /// specified, then a fresh set of randomness will be used to create the seed.
        /// When using REST, this field must be encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcGenSeedResponse> GenSeedAsync(byte[] aezeed_passphrase, byte[] seed_entropy)
        {
            return GenSeedAsync(aezeed_passphrase, seed_entropy, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// GenSeed is the first method that should be used to instantiate a new lnd
        /// instance. This method allows a caller to generate a new aezeed cipher seed
        /// given an optional passphrase. If provided, the passphrase will be necessary
        /// to decrypt the cipherseed to expose the internal wallet seed.</summary>
        /// <param name="aezeed_passphrase">*
        /// aezeed_passphrase is an optional user provided passphrase that will be used
        /// to encrypt the generated aezeed cipher seed. When using REST, this field
        /// must be encoded as base64.</param>
        /// <param name="seed_entropy">*
        /// seed_entropy is an optional 16-bytes generated via CSPRNG. If not
        /// specified, then a fresh set of randomness will be used to create the seed.
        /// When using REST, this field must be encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcGenSeedResponse> GenSeedAsync(byte[] aezeed_passphrase, byte[] seed_entropy, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/genseed?");
            if (aezeed_passphrase != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("aezeed_passphrase") + "=").Append(System.Uri.EscapeDataString(ConvertToString(aezeed_passphrase, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (seed_entropy != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("seed_entropy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(seed_entropy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcGenSeedResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcGenSeedResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `getinfo`
        /// GetInfo returns general information concerning the lightning node including
        /// it's identity pubkey, alias, the chains it is connected to, and information
        /// concerning the number of open+pending channels.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcGetInfoResponse> GetInfoAsync()
        {
            return GetInfoAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `getinfo`
        /// GetInfo returns general information concerning the lightning node including
        /// it's identity pubkey, alias, the chains it is connected to, and information
        /// concerning the number of open+pending channels.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcGetInfoResponse> GetInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/getinfo");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcGetInfoResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcGetInfoResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `describegraph`
        /// DescribeGraph returns a description of the latest graph state from the
        /// point of view of the node. The graph information is partitioned into two
        /// components: all the nodes/vertexes, and all the edges that connect the
        /// vertexes themselves. As this is a directed graph, the edges also contain
        /// the node directional specific routing policy which includes: the time lock
        /// delta, fee information, etc.</summary>
        /// <param name="include_unannounced">*
        /// Whether unannounced channels are included in the response or not. If set,
        /// unannounced channels are included. Unannounced channels are both private
        /// channels, and public channels that are not yet announced to the network.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChannelGraph> DescribeGraphAsync(bool? include_unannounced)
        {
            return DescribeGraphAsync(include_unannounced, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `describegraph`
        /// DescribeGraph returns a description of the latest graph state from the
        /// point of view of the node. The graph information is partitioned into two
        /// components: all the nodes/vertexes, and all the edges that connect the
        /// vertexes themselves. As this is a directed graph, the edges also contain
        /// the node directional specific routing policy which includes: the time lock
        /// delta, fee information, etc.</summary>
        /// <param name="include_unannounced">*
        /// Whether unannounced channels are included in the response or not. If set,
        /// unannounced channels are included. Unannounced channels are both private
        /// channels, and public channels that are not yet announced to the network.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChannelGraph> DescribeGraphAsync(bool? include_unannounced, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph?");
            if (include_unannounced != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("include_unannounced") + "=").Append(System.Uri.EscapeDataString(ConvertToString(include_unannounced, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChannelGraph>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChannelGraph);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `getchaninfo`
        /// GetChanInfo returns the latest authenticated network announcement for the
        /// given channel identified by its channel ID: an 8-byte integer which
        /// uniquely identifies the location of transaction's funding output within the
        /// blockchain.</summary>
        /// <param name="chan_id">*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcChannelEdge> GetChanInfoAsync(string chan_id)
        {
            return GetChanInfoAsync(chan_id, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `getchaninfo`
        /// GetChanInfo returns the latest authenticated network announcement for the
        /// given channel identified by its channel ID: an 8-byte integer which
        /// uniquely identifies the location of transaction's funding output within the
        /// blockchain.</summary>
        /// <param name="chan_id">*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcChannelEdge> GetChanInfoAsync(string chan_id, System.Threading.CancellationToken cancellationToken)
        {
            if (chan_id == null)
                throw new System.ArgumentNullException("chan_id");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph/edge/{chan_id}");
            urlBuilder_.Replace("{chan_id}", System.Uri.EscapeDataString(ConvertToString(chan_id, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcChannelEdge>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcChannelEdge);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `getnetworkinfo`
        /// GetNetworkInfo returns some basic stats about the known channel graph from
        /// the point of view of the node.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcNetworkInfo> GetNetworkInfoAsync()
        {
            return GetNetworkInfoAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `getnetworkinfo`
        /// GetNetworkInfo returns some basic stats about the known channel graph from
        /// the point of view of the node.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcNetworkInfo> GetNetworkInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph/info");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcNetworkInfo>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcNetworkInfo);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `getnodeinfo`
        /// GetNodeInfo returns the latest advertised, aggregated, and authenticated
        /// channel information for the specified node identified by its public key.</summary>
        /// <param name="pub_key">/ The 33-byte hex-encoded compressed public of the target node</param>
        /// <param name="include_channels">/ If true, will include all known channels associated with the node.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcNodeInfo> GetNodeInfoAsync(string pub_key, bool? include_channels)
        {
            return GetNodeInfoAsync(pub_key, include_channels, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `getnodeinfo`
        /// GetNodeInfo returns the latest advertised, aggregated, and authenticated
        /// channel information for the specified node identified by its public key.</summary>
        /// <param name="pub_key">/ The 33-byte hex-encoded compressed public of the target node</param>
        /// <param name="include_channels">/ If true, will include all known channels associated with the node.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcNodeInfo> GetNodeInfoAsync(string pub_key, bool? include_channels, System.Threading.CancellationToken cancellationToken)
        {
            if (pub_key == null)
                throw new System.ArgumentNullException("pub_key");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph/node/{pub_key}?");
            urlBuilder_.Replace("{pub_key}", System.Uri.EscapeDataString(ConvertToString(pub_key, System.Globalization.CultureInfo.InvariantCulture)));
            if (include_channels != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("include_channels") + "=").Append(System.Uri.EscapeDataString(ConvertToString(include_channels, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcNodeInfo>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcNodeInfo);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `getnodemetrics`
        /// GetNodeMetrics returns node metrics calculated from the graph. Currently
        /// the only supported metric is betweenness centrality of individual nodes.</summary>
        /// <param name="types">/ The requested node metrics.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcNodeMetricsResponse> GetNodeMetricsAsync(System.Collections.Generic.IEnumerable<Anonymous> types)
        {
            return GetNodeMetricsAsync(types, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `getnodemetrics`
        /// GetNodeMetrics returns node metrics calculated from the graph. Currently
        /// the only supported metric is betweenness centrality of individual nodes.</summary>
        /// <param name="types">/ The requested node metrics.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcNodeMetricsResponse> GetNodeMetricsAsync(System.Collections.Generic.IEnumerable<Anonymous> types, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph/nodemetrics?");
            if (types != null) 
            {
                foreach (var item_ in types) { urlBuilder_.Append(System.Uri.EscapeDataString("types") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcNodeMetricsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcNodeMetricsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `queryroutes`
        /// QueryRoutes attempts to query the daemon's Channel Router for a possible
        /// route to a target destination capable of carrying a specific amount of
        /// satoshis. The returned route contains the full details required to craft and
        /// send an HTLC, also including the necessary information that should be
        /// present within the Sphinx packet encapsulated within the HTLC.</summary>
        /// <param name="pub_key">/ The 33-byte hex-encoded public key for the payment destination</param>
        /// <param name="amt">*
        /// The amount to send expressed in satoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</param>
        /// <param name="amt_msat">*
        /// The amount to send expressed in millisatoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</param>
        /// <param name="final_cltv_delta">*
        /// An optional CLTV delta from the current height that should be used for the
        /// timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
        /// not add any additional block padding on top of final_ctlv_delta. This
        /// padding of a few blocks needs to be added manually or otherwise failures may
        /// happen when a block comes in while the payment is in flight.</param>
        /// <param name="fee_limit_fixed">*
        /// The fee limit expressed as a fixed amount of satoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</param>
        /// <param name="fee_limit_fixed_msat">*
        /// The fee limit expressed as a fixed amount of millisatoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</param>
        /// <param name="fee_limit_percent">/ The fee limit expressed as a percentage of the payment amount.</param>
        /// <param name="ignored_nodes">*
        /// A list of nodes to ignore during path finding. When using REST, these fields
        /// must be encoded as base64.</param>
        /// <param name="source_pub_key">*
        /// The source node where the request route should originated from. If empty,
        /// self is assumed.</param>
        /// <param name="use_mission_control">*
        /// If set to true, edge probabilities from mission control will be used to get
        /// the optimal route.</param>
        /// <param name="cltv_limit">*
        /// An optional maximum total time lock for the route. If the source is empty or
        /// ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
        /// zero, then the value of `--max-cltv-expiry` is used as the limit.</param>
        /// <param name="outgoing_chan_id">*
        /// The channel id of the channel that must be taken to the first hop. If zero,
        /// any channel may be used.</param>
        /// <param name="last_hop_pubkey">*
        /// The pubkey of the last hop of the route. If empty, any hop may be used.</param>
        /// <param name="dest_features">*
        /// Features assumed to be supported by the final node. All transitive feature
        /// dependencies must also be set properly. For a given feature bit pair, either
        /// optional or remote may be set, but not both. If this field is nil or empty,
        /// the router will try to load destination features from the graph as a
        /// fallback.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcQueryRoutesResponse> QueryRoutesAsync(string pub_key, string amt, string amt_msat, int? final_cltv_delta, string fee_limit_fixed, string fee_limit_fixed_msat, string fee_limit_percent, System.Collections.Generic.IEnumerable<byte[]> ignored_nodes, string source_pub_key, bool? use_mission_control, long? cltv_limit, string outgoing_chan_id, byte[] last_hop_pubkey, System.Collections.Generic.IEnumerable<Anonymous2> dest_features)
        {
            return QueryRoutesAsync(pub_key, amt, amt_msat, final_cltv_delta, fee_limit_fixed, fee_limit_fixed_msat, fee_limit_percent, ignored_nodes, source_pub_key, use_mission_control, cltv_limit, outgoing_chan_id, last_hop_pubkey, dest_features, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `queryroutes`
        /// QueryRoutes attempts to query the daemon's Channel Router for a possible
        /// route to a target destination capable of carrying a specific amount of
        /// satoshis. The returned route contains the full details required to craft and
        /// send an HTLC, also including the necessary information that should be
        /// present within the Sphinx packet encapsulated within the HTLC.</summary>
        /// <param name="pub_key">/ The 33-byte hex-encoded public key for the payment destination</param>
        /// <param name="amt">*
        /// The amount to send expressed in satoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</param>
        /// <param name="amt_msat">*
        /// The amount to send expressed in millisatoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</param>
        /// <param name="final_cltv_delta">*
        /// An optional CLTV delta from the current height that should be used for the
        /// timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
        /// not add any additional block padding on top of final_ctlv_delta. This
        /// padding of a few blocks needs to be added manually or otherwise failures may
        /// happen when a block comes in while the payment is in flight.</param>
        /// <param name="fee_limit_fixed">*
        /// The fee limit expressed as a fixed amount of satoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</param>
        /// <param name="fee_limit_fixed_msat">*
        /// The fee limit expressed as a fixed amount of millisatoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</param>
        /// <param name="fee_limit_percent">/ The fee limit expressed as a percentage of the payment amount.</param>
        /// <param name="ignored_nodes">*
        /// A list of nodes to ignore during path finding. When using REST, these fields
        /// must be encoded as base64.</param>
        /// <param name="source_pub_key">*
        /// The source node where the request route should originated from. If empty,
        /// self is assumed.</param>
        /// <param name="use_mission_control">*
        /// If set to true, edge probabilities from mission control will be used to get
        /// the optimal route.</param>
        /// <param name="cltv_limit">*
        /// An optional maximum total time lock for the route. If the source is empty or
        /// ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
        /// zero, then the value of `--max-cltv-expiry` is used as the limit.</param>
        /// <param name="outgoing_chan_id">*
        /// The channel id of the channel that must be taken to the first hop. If zero,
        /// any channel may be used.</param>
        /// <param name="last_hop_pubkey">*
        /// The pubkey of the last hop of the route. If empty, any hop may be used.</param>
        /// <param name="dest_features">*
        /// Features assumed to be supported by the final node. All transitive feature
        /// dependencies must also be set properly. For a given feature bit pair, either
        /// optional or remote may be set, but not both. If this field is nil or empty,
        /// the router will try to load destination features from the graph as a
        /// fallback.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcQueryRoutesResponse> QueryRoutesAsync(string pub_key, string amt, string amt_msat, int? final_cltv_delta, string fee_limit_fixed, string fee_limit_fixed_msat, string fee_limit_percent, System.Collections.Generic.IEnumerable<byte[]> ignored_nodes, string source_pub_key, bool? use_mission_control, long? cltv_limit, string outgoing_chan_id, byte[] last_hop_pubkey, System.Collections.Generic.IEnumerable<Anonymous2> dest_features, System.Threading.CancellationToken cancellationToken)
        {
            if (pub_key == null)
                throw new System.ArgumentNullException("pub_key");
    
            if (amt == null)
                throw new System.ArgumentNullException("amt");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/graph/routes/{pub_key}/{amt}?");
            urlBuilder_.Replace("{pub_key}", System.Uri.EscapeDataString(ConvertToString(pub_key, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{amt}", System.Uri.EscapeDataString(ConvertToString(amt, System.Globalization.CultureInfo.InvariantCulture)));
            if (amt_msat != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("amt_msat") + "=").Append(System.Uri.EscapeDataString(ConvertToString(amt_msat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (final_cltv_delta != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("final_cltv_delta") + "=").Append(System.Uri.EscapeDataString(ConvertToString(final_cltv_delta, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fee_limit_fixed != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fee_limit.fixed") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fee_limit_fixed, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fee_limit_fixed_msat != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fee_limit.fixed_msat") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fee_limit_fixed_msat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fee_limit_percent != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fee_limit.percent") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fee_limit_percent, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (ignored_nodes != null) 
            {
                foreach (var item_ in ignored_nodes) { urlBuilder_.Append(System.Uri.EscapeDataString("ignored_nodes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (source_pub_key != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("source_pub_key") + "=").Append(System.Uri.EscapeDataString(ConvertToString(source_pub_key, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (use_mission_control != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("use_mission_control") + "=").Append(System.Uri.EscapeDataString(ConvertToString(use_mission_control, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (cltv_limit != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("cltv_limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(cltv_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (outgoing_chan_id != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("outgoing_chan_id") + "=").Append(System.Uri.EscapeDataString(ConvertToString(outgoing_chan_id, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (last_hop_pubkey != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("last_hop_pubkey") + "=").Append(System.Uri.EscapeDataString(ConvertToString(last_hop_pubkey, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (dest_features != null) 
            {
                foreach (var item_ in dest_features) { urlBuilder_.Append(System.Uri.EscapeDataString("dest_features") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcQueryRoutesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcQueryRoutesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// InitWallet is used when lnd is starting up for the first time to fully
        /// initialize the daemon and its internal wallet. At the very least a wallet
        /// password must be provided. This will be used to encrypt sensitive material
        /// on disk.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcInitWalletResponse> InitWalletAsync(LnrpcInitWalletRequest body)
        {
            return InitWalletAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// InitWallet is used when lnd is starting up for the first time to fully
        /// initialize the daemon and its internal wallet. At the very least a wallet
        /// password must be provided. This will be used to encrypt sensitive material
        /// on disk.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcInitWalletResponse> InitWalletAsync(LnrpcInitWalletRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/initwallet");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcInitWalletResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcInitWalletResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `lookupinvoice`
        /// LookupInvoice attempts to look up an invoice according to its payment hash.
        /// The passed payment hash *must* be exactly 32 bytes, if not, an error is
        /// returned.</summary>
        /// <param name="r_hash_str">*
        /// The hex-encoded payment hash of the invoice to be looked up. The passed
        /// payment hash must be exactly 32 bytes, otherwise an error is returned.
        /// Deprecated now that the REST gateway supports base64 encoding of bytes
        /// fields.</param>
        /// <param name="r_hash">*
        /// The payment hash of the invoice to be looked up. When using REST, this field
        /// must be encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcInvoice> LookupInvoiceAsync(string r_hash_str, byte[] r_hash)
        {
            return LookupInvoiceAsync(r_hash_str, r_hash, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `lookupinvoice`
        /// LookupInvoice attempts to look up an invoice according to its payment hash.
        /// The passed payment hash *must* be exactly 32 bytes, if not, an error is
        /// returned.</summary>
        /// <param name="r_hash_str">*
        /// The hex-encoded payment hash of the invoice to be looked up. The passed
        /// payment hash must be exactly 32 bytes, otherwise an error is returned.
        /// Deprecated now that the REST gateway supports base64 encoding of bytes
        /// fields.</param>
        /// <param name="r_hash">*
        /// The payment hash of the invoice to be looked up. When using REST, this field
        /// must be encoded as base64.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcInvoice> LookupInvoiceAsync(string r_hash_str, byte[] r_hash, System.Threading.CancellationToken cancellationToken)
        {
            if (r_hash_str == null)
                throw new System.ArgumentNullException("r_hash_str");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/invoice/{r_hash_str}?");
            urlBuilder_.Replace("{r_hash_str}", System.Uri.EscapeDataString(ConvertToString(r_hash_str, System.Globalization.CultureInfo.InvariantCulture)));
            if (r_hash != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("r_hash") + "=").Append(System.Uri.EscapeDataString(ConvertToString(r_hash, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcInvoice>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcInvoice);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listinvoices`
        /// ListInvoices returns a list of all the invoices currently stored within the
        /// database. Any active debug invoices are ignored. It has full support for
        /// paginated responses, allowing users to query for specific invoices through
        /// their add_index. This can be done by using either the first_index_offset or
        /// last_index_offset fields included in the response as the index_offset of the
        /// next request. By default, the first 100 invoices created will be returned.
        /// Backwards pagination is also supported through the Reversed flag.</summary>
        /// <param name="pending_only">*
        /// If set, only invoices that are not settled and not canceled will be returned
        /// in the response.</param>
        /// <param name="index_offset">*
        /// The index of an invoice that will be used as either the start or end of a
        /// query to determine which invoices should be returned in the response.</param>
        /// <param name="num_max_invoices">/ The max number of invoices to return in the response to this query.</param>
        /// <param name="reversed">*
        /// If set, the invoices returned will result from seeking backwards from the
        /// specified index offset. This can be used to paginate backwards.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcListInvoiceResponse> ListInvoicesAsync(bool? pending_only, string index_offset, string num_max_invoices, bool? reversed)
        {
            return ListInvoicesAsync(pending_only, index_offset, num_max_invoices, reversed, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listinvoices`
        /// ListInvoices returns a list of all the invoices currently stored within the
        /// database. Any active debug invoices are ignored. It has full support for
        /// paginated responses, allowing users to query for specific invoices through
        /// their add_index. This can be done by using either the first_index_offset or
        /// last_index_offset fields included in the response as the index_offset of the
        /// next request. By default, the first 100 invoices created will be returned.
        /// Backwards pagination is also supported through the Reversed flag.</summary>
        /// <param name="pending_only">*
        /// If set, only invoices that are not settled and not canceled will be returned
        /// in the response.</param>
        /// <param name="index_offset">*
        /// The index of an invoice that will be used as either the start or end of a
        /// query to determine which invoices should be returned in the response.</param>
        /// <param name="num_max_invoices">/ The max number of invoices to return in the response to this query.</param>
        /// <param name="reversed">*
        /// If set, the invoices returned will result from seeking backwards from the
        /// specified index offset. This can be used to paginate backwards.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcListInvoiceResponse> ListInvoicesAsync(bool? pending_only, string index_offset, string num_max_invoices, bool? reversed, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/invoices?");
            if (pending_only != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("pending_only") + "=").Append(System.Uri.EscapeDataString(ConvertToString(pending_only, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (index_offset != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("index_offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(index_offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (num_max_invoices != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("num_max_invoices") + "=").Append(System.Uri.EscapeDataString(ConvertToString(num_max_invoices, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (reversed != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("reversed") + "=").Append(System.Uri.EscapeDataString(ConvertToString(reversed, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcListInvoiceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcListInvoiceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `addinvoice`
        /// AddInvoice attempts to add a new invoice to the invoice database. Any
        /// duplicated invoices are rejected, therefore all invoices *must* have a
        /// unique payment preimage.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcAddInvoiceResponse> AddInvoiceAsync(LnrpcInvoice body)
        {
            return AddInvoiceAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `addinvoice`
        /// AddInvoice attempts to add a new invoice to the invoice database. Any
        /// duplicated invoices are rejected, therefore all invoices *must* have a
        /// unique payment preimage.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcAddInvoiceResponse> AddInvoiceAsync(LnrpcInvoice body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/invoices");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcAddInvoiceResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcAddInvoiceResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// SubscribeInvoices returns a uni-directional stream (server -&gt; client) for
        /// notifying the client of newly added/settled invoices. The caller can
        /// optionally specify the add_index and/or the settle_index. If the add_index
        /// is specified, then we'll first start by sending add invoice events for all
        /// invoices with an add_index greater than the specified value. If the
        /// settle_index is specified, the next, we'll send out all settle events for
        /// invoices with a settle_index greater than the specified value. One or both
        /// of these fields can be set. If no fields are set, then we'll only send out
        /// the latest add/settle events.</summary>
        /// <param name="add_index">*
        /// If specified (non-zero), then we'll first start by sending out
        /// notifications for all added indexes with an add_index greater than this
        /// value. This allows callers to catch up on any events they missed while they
        /// weren't connected to the streaming RPC.</param>
        /// <param name="settle_index">*
        /// If specified (non-zero), then we'll first start by sending out
        /// notifications for all settled indexes with an settle_index greater than
        /// this value. This allows callers to catch up on any events they missed while
        /// they weren't connected to the streaming RPC.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<Response2> SubscribeInvoicesAsync(string add_index, string settle_index)
        {
            return SubscribeInvoicesAsync(add_index, settle_index, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// SubscribeInvoices returns a uni-directional stream (server -&gt; client) for
        /// notifying the client of newly added/settled invoices. The caller can
        /// optionally specify the add_index and/or the settle_index. If the add_index
        /// is specified, then we'll first start by sending add invoice events for all
        /// invoices with an add_index greater than the specified value. If the
        /// settle_index is specified, the next, we'll send out all settle events for
        /// invoices with a settle_index greater than the specified value. One or both
        /// of these fields can be set. If no fields are set, then we'll only send out
        /// the latest add/settle events.</summary>
        /// <param name="add_index">*
        /// If specified (non-zero), then we'll first start by sending out
        /// notifications for all added indexes with an add_index greater than this
        /// value. This allows callers to catch up on any events they missed while they
        /// weren't connected to the streaming RPC.</param>
        /// <param name="settle_index">*
        /// If specified (non-zero), then we'll first start by sending out
        /// notifications for all settled indexes with an settle_index greater than
        /// this value. This allows callers to catch up on any events they missed while
        /// they weren't connected to the streaming RPC.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<Response2> SubscribeInvoicesAsync(string add_index, string settle_index, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/invoices/subscribe?");
            if (add_index != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("add_index") + "=").Append(System.Uri.EscapeDataString(ConvertToString(add_index, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (settle_index != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("settle_index") + "=").Append(System.Uri.EscapeDataString(ConvertToString(settle_index, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(Response2);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `bakemacaroon`
        /// BakeMacaroon allows the creation of a new macaroon with custom read and
        /// write permissions. No first-party caveats are added since this can be done
        /// offline.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcBakeMacaroonResponse> BakeMacaroonAsync(LnrpcBakeMacaroonRequest body)
        {
            return BakeMacaroonAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `bakemacaroon`
        /// BakeMacaroon allows the creation of a new macaroon with custom read and
        /// write permissions. No first-party caveats are added since this can be done
        /// offline.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcBakeMacaroonResponse> BakeMacaroonAsync(LnrpcBakeMacaroonRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/macaroon");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcBakeMacaroonResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcBakeMacaroonResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `newaddress`
        /// NewAddress creates a new address under control of the local wallet.</summary>
        /// <param name="type">/ The address type.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcNewAddressResponse> NewAddressAsync(Type? type)
        {
            return NewAddressAsync(type, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `newaddress`
        /// NewAddress creates a new address under control of the local wallet.</summary>
        /// <param name="type">/ The address type.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcNewAddressResponse> NewAddressAsync(Type? type, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/newaddress?");
            if (type != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("type") + "=").Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcNewAddressResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcNewAddressResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listpayments`
        /// ListPayments returns a list of all outgoing payments.</summary>
        /// <param name="include_incomplete">*
        /// If true, then return payments that have not yet fully completed. This means
        /// that pending payments, as well as failed payments will show up if this
        /// field is set to true. This flag doesn't change the meaning of the indices,
        /// which are tied to individual payments.</param>
        /// <param name="index_offset">*
        /// The index of a payment that will be used as either the start or end of a
        /// query to determine which payments should be returned in the response. The
        /// index_offset is exclusive. In the case of a zero index_offset, the query
        /// will start with the oldest payment when paginating forwards, or will end
        /// with the most recent payment when paginating backwards.</param>
        /// <param name="max_payments">/ The maximal number of payments returned in the response to this query.</param>
        /// <param name="reversed">*
        /// If set, the payments returned will result from seeking backwards from the
        /// specified index offset. This can be used to paginate backwards. The order
        /// of the returned payments is always oldest first (ascending index order).</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcListPaymentsResponse> ListPaymentsAsync(bool? include_incomplete, string index_offset, string max_payments, bool? reversed)
        {
            return ListPaymentsAsync(include_incomplete, index_offset, max_payments, reversed, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listpayments`
        /// ListPayments returns a list of all outgoing payments.</summary>
        /// <param name="include_incomplete">*
        /// If true, then return payments that have not yet fully completed. This means
        /// that pending payments, as well as failed payments will show up if this
        /// field is set to true. This flag doesn't change the meaning of the indices,
        /// which are tied to individual payments.</param>
        /// <param name="index_offset">*
        /// The index of a payment that will be used as either the start or end of a
        /// query to determine which payments should be returned in the response. The
        /// index_offset is exclusive. In the case of a zero index_offset, the query
        /// will start with the oldest payment when paginating forwards, or will end
        /// with the most recent payment when paginating backwards.</param>
        /// <param name="max_payments">/ The maximal number of payments returned in the response to this query.</param>
        /// <param name="reversed">*
        /// If set, the payments returned will result from seeking backwards from the
        /// specified index offset. This can be used to paginate backwards. The order
        /// of the returned payments is always oldest first (ascending index order).</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcListPaymentsResponse> ListPaymentsAsync(bool? include_incomplete, string index_offset, string max_payments, bool? reversed, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/payments?");
            if (include_incomplete != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("include_incomplete") + "=").Append(System.Uri.EscapeDataString(ConvertToString(include_incomplete, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (index_offset != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("index_offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(index_offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (max_payments != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("max_payments") + "=").Append(System.Uri.EscapeDataString(ConvertToString(max_payments, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (reversed != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("reversed") + "=").Append(System.Uri.EscapeDataString(ConvertToString(reversed, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcListPaymentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcListPaymentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>*
        /// DeleteAllPayments deletes all outgoing payments from DB.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcDeleteAllPaymentsResponse> DeleteAllPaymentsAsync()
        {
            return DeleteAllPaymentsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>*
        /// DeleteAllPayments deletes all outgoing payments from DB.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcDeleteAllPaymentsResponse> DeleteAllPaymentsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/payments");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcDeleteAllPaymentsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcDeleteAllPaymentsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `decodepayreq`
        /// DecodePayReq takes an encoded payment request string and attempts to decode
        /// it, returning a full description of the conditions encoded within the
        /// payment request.</summary>
        /// <param name="pay_req">/ The payment request string to be decoded</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcPayReq> DecodePayReqAsync(string pay_req)
        {
            return DecodePayReqAsync(pay_req, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `decodepayreq`
        /// DecodePayReq takes an encoded payment request string and attempts to decode
        /// it, returning a full description of the conditions encoded within the
        /// payment request.</summary>
        /// <param name="pay_req">/ The payment request string to be decoded</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcPayReq> DecodePayReqAsync(string pay_req, System.Threading.CancellationToken cancellationToken)
        {
            if (pay_req == null)
                throw new System.ArgumentNullException("pay_req");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/payreq/{pay_req}");
            urlBuilder_.Replace("{pay_req}", System.Uri.EscapeDataString(ConvertToString(pay_req, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcPayReq>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcPayReq);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listpeers`
        /// ListPeers returns a verbose listing of all currently active peers.</summary>
        /// <param name="latest_error">If true, only the last error that our peer sent us will be returned with
        /// the peer's information, rather than the full set of historic errors we have
        /// stored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcListPeersResponse> ListPeersAsync(bool? latest_error)
        {
            return ListPeersAsync(latest_error, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listpeers`
        /// ListPeers returns a verbose listing of all currently active peers.</summary>
        /// <param name="latest_error">If true, only the last error that our peer sent us will be returned with
        /// the peer's information, rather than the full set of historic errors we have
        /// stored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcListPeersResponse> ListPeersAsync(bool? latest_error, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/peers?");
            if (latest_error != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("latest_error") + "=").Append(System.Uri.EscapeDataString(ConvertToString(latest_error, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcListPeersResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcListPeersResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `connect`
        /// ConnectPeer attempts to establish a connection to a remote peer. This is at
        /// the networking level, and is used for communication between nodes. This is
        /// distinct from establishing a channel with a peer.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcConnectPeerResponse> ConnectPeerAsync(LnrpcConnectPeerRequest body)
        {
            return ConnectPeerAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `connect`
        /// ConnectPeer attempts to establish a connection to a remote peer. This is at
        /// the networking level, and is used for communication between nodes. This is
        /// distinct from establishing a channel with a peer.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcConnectPeerResponse> ConnectPeerAsync(LnrpcConnectPeerRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/peers");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcConnectPeerResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcConnectPeerResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `disconnect`
        /// DisconnectPeer attempts to disconnect one peer from another identified by a
        /// given pubKey. In the case that we currently have a pending or active channel
        /// with the target peer, then this action will be not be allowed.</summary>
        /// <param name="pub_key">/ The pubkey of the node to disconnect from</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcDisconnectPeerResponse> DisconnectPeerAsync(string pub_key)
        {
            return DisconnectPeerAsync(pub_key, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `disconnect`
        /// DisconnectPeer attempts to disconnect one peer from another identified by a
        /// given pubKey. In the case that we currently have a pending or active channel
        /// with the target peer, then this action will be not be allowed.</summary>
        /// <param name="pub_key">/ The pubkey of the node to disconnect from</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcDisconnectPeerResponse> DisconnectPeerAsync(string pub_key, System.Threading.CancellationToken cancellationToken)
        {
            if (pub_key == null)
                throw new System.ArgumentNullException("pub_key");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/peers/{pub_key}");
            urlBuilder_.Replace("{pub_key}", System.Uri.EscapeDataString(ConvertToString(pub_key, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcDisconnectPeerResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcDisconnectPeerResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `signmessage`
        /// SignMessage signs a message with this node's private key. The returned
        /// signature string is `zbase32` encoded and pubkey recoverable, meaning that
        /// only the message digest and signature are needed for verification.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcSignMessageResponse> SignMessageAsync(LnrpcSignMessageRequest body)
        {
            return SignMessageAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `signmessage`
        /// SignMessage signs a message with this node's private key. The returned
        /// signature string is `zbase32` encoded and pubkey recoverable, meaning that
        /// only the message digest and signature are needed for verification.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcSignMessageResponse> SignMessageAsync(LnrpcSignMessageRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/signmessage");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcSignMessageResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcSignMessageResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `fwdinghistory`
        /// ForwardingHistory allows the caller to query the htlcswitch for a record of
        /// all HTLCs forwarded within the target time range, and integer offset
        /// within that time range. If no time-range is specified, then the first chunk
        /// of the past 24 hrs of forwarding history are returned.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcForwardingHistoryResponse> ForwardingHistoryAsync(LnrpcForwardingHistoryRequest body)
        {
            return ForwardingHistoryAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `fwdinghistory`
        /// ForwardingHistory allows the caller to query the htlcswitch for a record of
        /// all HTLCs forwarded within the target time range, and integer offset
        /// within that time range. If no time-range is specified, then the first chunk
        /// of the past 24 hrs of forwarding history are returned.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcForwardingHistoryResponse> ForwardingHistoryAsync(LnrpcForwardingHistoryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/switch");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcForwardingHistoryResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcForwardingHistoryResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listchaintxns`
        /// GetTransactions returns a list describing all the known transactions
        /// relevant to the wallet.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcTransactionDetails> GetTransactionsAsync()
        {
            return GetTransactionsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listchaintxns`
        /// GetTransactions returns a list describing all the known transactions
        /// relevant to the wallet.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcTransactionDetails> GetTransactionsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/transactions");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcTransactionDetails>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcTransactionDetails);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `sendcoins`
        /// SendCoins executes a request to send coins to a particular address. Unlike
        /// SendMany, this RPC call only allows creating a single output at a time. If
        /// neither target_conf, or sat_per_byte are set, then the internal wallet will
        /// consult its fee model to determine a fee for the default confirmation
        /// target.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcSendCoinsResponse> SendCoinsAsync(LnrpcSendCoinsRequest body)
        {
            return SendCoinsAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `sendcoins`
        /// SendCoins executes a request to send coins to a particular address. Unlike
        /// SendMany, this RPC call only allows creating a single output at a time. If
        /// neither target_conf, or sat_per_byte are set, then the internal wallet will
        /// consult its fee model to determine a fee for the default confirmation
        /// target.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcSendCoinsResponse> SendCoinsAsync(LnrpcSendCoinsRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/transactions");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcSendCoinsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcSendCoinsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `estimatefee`
        /// EstimateFee asks the chain backend to estimate the fee rate and total fees
        /// for a transaction that pays to multiple specified outputs.</summary>
        /// <param name="target_conf">/ The target number of blocks that this transaction should be confirmed
        /// / by.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcEstimateFeeResponse> EstimateFeeAsync(int? target_conf)
        {
            return EstimateFeeAsync(target_conf, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `estimatefee`
        /// EstimateFee asks the chain backend to estimate the fee rate and total fees
        /// for a transaction that pays to multiple specified outputs.</summary>
        /// <param name="target_conf">/ The target number of blocks that this transaction should be confirmed
        /// / by.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcEstimateFeeResponse> EstimateFeeAsync(int? target_conf, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/transactions/fee?");
            if (target_conf != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("target_conf") + "=").Append(System.Uri.EscapeDataString(ConvertToString(target_conf, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcEstimateFeeResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcEstimateFeeResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `unlock`
        /// UnlockWallet is used at startup of lnd to provide a password to unlock
        /// the wallet database.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcUnlockWalletResponse> UnlockWalletAsync(LnrpcUnlockWalletRequest body)
        {
            return UnlockWalletAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `unlock`
        /// UnlockWallet is used at startup of lnd to provide a password to unlock
        /// the wallet database.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcUnlockWalletResponse> UnlockWalletAsync(LnrpcUnlockWalletRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/unlockwallet");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcUnlockWalletResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcUnlockWalletResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `listunspent`
        /// ListUnspent returns a list of all utxos spendable by the wallet with a
        /// number of confirmations between the specified minimum and maximum.</summary>
        /// <param name="min_confs">/ The minimum number of confirmations to be included.</param>
        /// <param name="max_confs">/ The maximum number of confirmations to be included.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcListUnspentResponse> ListUnspentAsync(int? min_confs, int? max_confs)
        {
            return ListUnspentAsync(min_confs, max_confs, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `listunspent`
        /// ListUnspent returns a list of all utxos spendable by the wallet with a
        /// number of confirmations between the specified minimum and maximum.</summary>
        /// <param name="min_confs">/ The minimum number of confirmations to be included.</param>
        /// <param name="max_confs">/ The maximum number of confirmations to be included.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcListUnspentResponse> ListUnspentAsync(int? min_confs, int? max_confs, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/utxos?");
            if (min_confs != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("min_confs") + "=").Append(System.Uri.EscapeDataString(ConvertToString(min_confs, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (max_confs != null) 
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("max_confs") + "=").Append(System.Uri.EscapeDataString(ConvertToString(max_confs, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcListUnspentResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcListUnspentResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>* lncli: `verifymessage`
        /// VerifyMessage verifies a signature over a msg. The signature must be
        /// zbase32 encoded and signed by an active node in the resident node's
        /// channel database. In addition to returning the validity of the signature,
        /// VerifyMessage also returns the recovered pubkey from the signature.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LnrpcVerifyMessageResponse> VerifyMessageAsync(LnrpcVerifyMessageRequest body)
        {
            return VerifyMessageAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>* lncli: `verifymessage`
        /// VerifyMessage verifies a signature over a msg. The signature must be
        /// zbase32 encoded and signed by an active node in the resident node's
        /// channel database. In addition to returning the validity of the signature,
        /// VerifyMessage also returns the recovered pubkey from the signature.</summary>
        /// <returns>A successful response.</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LnrpcVerifyMessageResponse> VerifyMessageAsync(LnrpcVerifyMessageRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/verifymessage");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LnrpcVerifyMessageResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LnrpcVerifyMessageResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new SwaggerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
        
                    return System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ChannelCloseSummaryClosureType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"COOPERATIVE_CLOSE")]
        COOPERATIVE_CLOSE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOCAL_FORCE_CLOSE")]
        LOCAL_FORCE_CLOSE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REMOTE_FORCE_CLOSE")]
        REMOTE_FORCE_CLOSE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BREACH_CLOSE")]
        BREACH_CLOSE = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FUNDING_CANCELED")]
        FUNDING_CANCELED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ABANDONED")]
        ABANDONED = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ChannelEventUpdateUpdateType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OPEN_CHANNEL")]
        OPEN_CHANNEL = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CLOSED_CHANNEL")]
        CLOSED_CHANNEL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_CHANNEL")]
        ACTIVE_CHANNEL = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INACTIVE_CHANNEL")]
        INACTIVE_CHANNEL = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING_OPEN_CHANNEL")]
        PENDING_OPEN_CHANNEL = 4,
    
    }
    
    /// <summary> - RESERVED: *
    /// The numbers assigned in this enumeration match the failure codes as
    /// defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
    /// a RESERVED value is added.
    ///  - INTERNAL_FAILURE: *
    /// An internal error occurred.
    ///  - UNKNOWN_FAILURE: *
    /// The error source is known, but the failure itself couldn't be decoded.
    ///  - UNREADABLE_FAILURE: *
    /// An unreadable failure result is returned if the received failure message
    /// cannot be decrypted. In that case the error source is unknown.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FailureFailureCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"RESERVED")]
        RESERVED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS")]
        INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INCORRECT_PAYMENT_AMOUNT")]
        INCORRECT_PAYMENT_AMOUNT = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FINAL_INCORRECT_CLTV_EXPIRY")]
        FINAL_INCORRECT_CLTV_EXPIRY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FINAL_INCORRECT_HTLC_AMOUNT")]
        FINAL_INCORRECT_HTLC_AMOUNT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FINAL_EXPIRY_TOO_SOON")]
        FINAL_EXPIRY_TOO_SOON = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_REALM")]
        INVALID_REALM = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRY_TOO_SOON")]
        EXPIRY_TOO_SOON = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_ONION_VERSION")]
        INVALID_ONION_VERSION = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_ONION_HMAC")]
        INVALID_ONION_HMAC = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_ONION_KEY")]
        INVALID_ONION_KEY = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AMOUNT_BELOW_MINIMUM")]
        AMOUNT_BELOW_MINIMUM = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FEE_INSUFFICIENT")]
        FEE_INSUFFICIENT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INCORRECT_CLTV_EXPIRY")]
        INCORRECT_CLTV_EXPIRY = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CHANNEL_DISABLED")]
        CHANNEL_DISABLED = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEMPORARY_CHANNEL_FAILURE")]
        TEMPORARY_CHANNEL_FAILURE = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REQUIRED_NODE_FEATURE_MISSING")]
        REQUIRED_NODE_FEATURE_MISSING = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"REQUIRED_CHANNEL_FEATURE_MISSING")]
        REQUIRED_CHANNEL_FEATURE_MISSING = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_NEXT_PEER")]
        UNKNOWN_NEXT_PEER = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEMPORARY_NODE_FAILURE")]
        TEMPORARY_NODE_FAILURE = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERMANENT_NODE_FAILURE")]
        PERMANENT_NODE_FAILURE = 20,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PERMANENT_CHANNEL_FAILURE")]
        PERMANENT_CHANNEL_FAILURE = 21,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXPIRY_TOO_FAR")]
        EXPIRY_TOO_FAR = 22,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPP_TIMEOUT")]
        MPP_TIMEOUT = 23,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INTERNAL_FAILURE")]
        INTERNAL_FAILURE = 24,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_FAILURE")]
        UNKNOWN_FAILURE = 25,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNREADABLE_FAILURE")]
        UNREADABLE_FAILURE = 26,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ForceClosedChannelAnchorState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LIMBO")]
        LIMBO = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RECOVERED")]
        RECOVERED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LOST")]
        LOST = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum HTLCAttemptHTLCStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"IN_FLIGHT")]
        IN_FLIGHT = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCEEDED")]
        SUCCEEDED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum InvoiceInvoiceState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OPEN")]
        OPEN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SETTLED")]
        SETTLED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELED")]
        CANCELED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PaymentPaymentStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"IN_FLIGHT")]
        IN_FLIGHT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCEEDED")]
        SUCCEEDED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PeerEventEventType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PEER_ONLINE")]
        PEER_ONLINE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PEER_OFFLINE")]
        PEER_OFFLINE = 1,
    
    }
    
    /// <summary> - UNKNOWN_SYNC: *
    /// Denotes that we cannot determine the peer's current sync type.
    ///  - ACTIVE_SYNC: *
    /// Denotes that we are actively receiving new graph updates from the peer.
    ///  - PASSIVE_SYNC: *
    /// Denotes that we are not receiving new graph updates from the peer.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PeerSyncType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_SYNC")]
        UNKNOWN_SYNC = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ACTIVE_SYNC")]
        ACTIVE_SYNC = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PASSIVE_SYNC")]
        PASSIVE_SYNC = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponseClosedChannel 
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChannelsResponsePendingChannel Channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("closing_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Closing_txid { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponseCommitments 
    {
        /// <summary>/ Hash of the local version of the commitment tx.</summary>
        [Newtonsoft.Json.JsonProperty("local_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_txid { get; set; }
    
        /// <summary>/ Hash of the remote version of the commitment tx.</summary>
        [Newtonsoft.Json.JsonProperty("remote_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_txid { get; set; }
    
        /// <summary>/ Hash of the remote pending version of the commitment tx.</summary>
        [Newtonsoft.Json.JsonProperty("remote_pending_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_pending_txid { get; set; }
    
        /// <summary>The amount in satoshis calculated to be paid in fees for the local
        /// commitment.</summary>
        [Newtonsoft.Json.JsonProperty("local_commit_fee_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_commit_fee_sat { get; set; }
    
        /// <summary>The amount in satoshis calculated to be paid in fees for the remote
        /// commitment.</summary>
        [Newtonsoft.Json.JsonProperty("remote_commit_fee_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_commit_fee_sat { get; set; }
    
        /// <summary>The amount in satoshis calculated to be paid in fees for the remote
        /// pending commitment.</summary>
        [Newtonsoft.Json.JsonProperty("remote_pending_commit_fee_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_pending_commit_fee_sat { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponseForceClosedChannel 
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChannelsResponsePendingChannel Channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("closing_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Closing_txid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("limbo_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Limbo_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maturity_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Maturity_height { get; set; }
    
        /// <summary>Remaining # of blocks until the commitment output can be swept.
        /// Negative values indicate how many blocks have passed since becoming
        /// mature.</summary>
        [Newtonsoft.Json.JsonProperty("blocks_til_maturity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Blocks_til_maturity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("recovered_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Recovered_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_htlcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcPendingHTLC> Pending_htlcs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("anchor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ForceClosedChannelAnchorState? Anchor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponsePendingChannel 
    {
        [Newtonsoft.Json.JsonProperty("remote_node_pub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_node_pub { get; set; }
    
        [Newtonsoft.Json.JsonProperty("channel_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_point { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("local_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("remote_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_balance { get; set; }
    
        /// <summary>/ The minimum satoshis this node is required to reserve in its
        /// / balance.</summary>
        [Newtonsoft.Json.JsonProperty("local_chan_reserve_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_chan_reserve_sat { get; set; }
    
        /// <summary>*
        /// The minimum satoshis the other node is required to reserve in its
        /// balance.</summary>
        [Newtonsoft.Json.JsonProperty("remote_chan_reserve_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_chan_reserve_sat { get; set; }
    
        /// <summary>The party that initiated opening the channel.</summary>
        [Newtonsoft.Json.JsonProperty("initiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcInitiator? Initiator { get; set; }
    
        /// <summary>/ The commitment type used by this channel.</summary>
        [Newtonsoft.Json.JsonProperty("commitment_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcCommitmentType? Commitment_type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponsePendingOpenChannel 
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChannelsResponsePendingChannel Channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("confirmation_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Confirmation_height { get; set; }
    
        /// <summary>*
        /// The amount calculated to be paid in fees for the current set of
        /// commitment transactions. The fee amount is persisted with the channel
        /// in order to allow the fee amount to be removed and recalculated with
        /// each channel state update, including updates that happen after a system
        /// restart.</summary>
        [Newtonsoft.Json.JsonProperty("commit_fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Commit_fee { get; set; }
    
        [Newtonsoft.Json.JsonProperty("commit_weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Commit_weight { get; set; }
    
        /// <summary>*
        /// The required number of satoshis per kilo-weight that the requester will
        /// pay at all times, for both the funding transaction and commitment
        /// transaction. This value can later be updated once the channel is open.</summary>
        [Newtonsoft.Json.JsonProperty("fee_per_kw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_per_kw { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class PendingChannelsResponseWaitingCloseChannel 
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChannelsResponsePendingChannel Channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("limbo_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Limbo_balance { get; set; }
    
        /// <summary>*
        /// A list of valid commitment transactions. Any of these can confirm at
        /// this point.</summary>
        [Newtonsoft.Json.JsonProperty("commitments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PendingChannelsResponseCommitments Commitments { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcAbandonChannelResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcAddInvoiceResponse 
    {
        [Newtonsoft.Json.JsonProperty("r_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] R_hash { get; set; }
    
        /// <summary>*
        /// A bare-bones invoice for a payment within the Lightning Network. With the
        /// details of the invoice, the sender has all the data necessary to send a
        /// payment to the recipient.</summary>
        [Newtonsoft.Json.JsonProperty("payment_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_request { get; set; }
    
        /// <summary>*
        /// The "add" index of this invoice. Each newly created invoice will increment
        /// this index making it monotonically increasing. Callers to the
        /// SubscribeInvoices call can use this to instantly get notified of all added
        /// invoices with an add_index greater than this one.</summary>
        [Newtonsoft.Json.JsonProperty("add_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Add_index { get; set; }
    
    
    }
    
    /// <summary>- `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
    /// - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcAddressType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WITNESS_PUBKEY_HASH")]
        WITNESS_PUBKEY_HASH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NESTED_PUBKEY_HASH")]
        NESTED_PUBKEY_HASH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNUSED_WITNESS_PUBKEY_HASH")]
        UNUSED_WITNESS_PUBKEY_HASH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNUSED_NESTED_PUBKEY_HASH")]
        UNUSED_NESTED_PUBKEY_HASH = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcBakeMacaroonRequest 
    {
        /// <summary>/ The list of permissions the new macaroon should grant.</summary>
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcMacaroonPermission> Permissions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcBakeMacaroonResponse 
    {
        /// <summary>/ The hex encoded macaroon, serialized in binary format.</summary>
        [Newtonsoft.Json.JsonProperty("macaroon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Macaroon { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChain 
    {
        [Newtonsoft.Json.JsonProperty("chain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chain { get; set; }
    
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChanBackupSnapshot 
    {
        /// <summary>*
        /// The set of new channels that have been added since the last channel backup
        /// snapshot was requested.</summary>
        [Newtonsoft.Json.JsonProperty("single_chan_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelBackups Single_chan_backups { get; set; }
    
        /// <summary>*
        /// A multi-channel backup that covers all open channels currently known to
        /// lnd.</summary>
        [Newtonsoft.Json.JsonProperty("multi_chan_backup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcMultiChanBackup Multi_chan_backup { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChanPointShim 
    {
        /// <summary>*
        /// The size of the pre-crafted output to be used as the channel point for this
        /// channel funding.</summary>
        [Newtonsoft.Json.JsonProperty("amt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt { get; set; }
    
        /// <summary>/ The target channel point to refrence in created commitment transactions.</summary>
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Chan_point { get; set; }
    
        /// <summary>/ Our local key to use when creating the multi-sig output.</summary>
        [Newtonsoft.Json.JsonProperty("local_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcKeyDescriptor Local_key { get; set; }
    
        /// <summary>/ The key of the remote party to use when creating the multi-sig output.</summary>
        [Newtonsoft.Json.JsonProperty("remote_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Remote_key { get; set; }
    
        /// <summary>*
        /// If non-zero, then this will be used as the pending channel ID on the wire
        /// protocol to initate the funding request. This is an optional field, and
        /// should only be set if the responder is already expecting a specific pending
        /// channel ID.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
        /// <summary>*
        /// This uint32 indicates if this channel is to be considered 'frozen'. A
        /// frozen channel does not allow a cooperative channel close by the
        /// initiator. The thaw_height is the height that this restriction stops
        /// applying to the channel.</summary>
        [Newtonsoft.Json.JsonProperty("thaw_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Thaw_height { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChangePasswordRequest 
    {
        /// <summary>*
        /// current_password should be the current valid passphrase used to unlock the
        /// daemon. When using REST, this field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("current_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Current_password { get; set; }
    
        /// <summary>*
        /// new_password should be the new passphrase that will be needed to unlock the
        /// daemon. When using REST, this field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("new_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] New_password { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChangePasswordResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannel 
    {
        [Newtonsoft.Json.JsonProperty("active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Active { get; set; }
    
        [Newtonsoft.Json.JsonProperty("remote_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_pubkey { get; set; }
    
        /// <summary>*
        /// The outpoint (txid:index) of the funding transaction. With this value, Bob
        /// will be able to generate a signature for Alice's version of the commitment
        /// transaction.</summary>
        [Newtonsoft.Json.JsonProperty("channel_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_point { get; set; }
    
        /// <summary>*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("local_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("remote_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_balance { get; set; }
    
        /// <summary>*
        /// The amount calculated to be paid in fees for the current set of commitment
        /// transactions. The fee amount is persisted with the channel in order to
        /// allow the fee amount to be removed and recalculated with each channel state
        /// update, including updates that happen after a system restart.</summary>
        [Newtonsoft.Json.JsonProperty("commit_fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Commit_fee { get; set; }
    
        [Newtonsoft.Json.JsonProperty("commit_weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Commit_weight { get; set; }
    
        /// <summary>*
        /// The required number of satoshis per kilo-weight that the requester will pay
        /// at all times, for both the funding transaction and commitment transaction.
        /// This value can later be updated once the channel is open.</summary>
        [Newtonsoft.Json.JsonProperty("fee_per_kw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_per_kw { get; set; }
    
        [Newtonsoft.Json.JsonProperty("unsettled_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unsettled_balance { get; set; }
    
        /// <summary>*
        /// The total number of satoshis we've sent within this channel.</summary>
        [Newtonsoft.Json.JsonProperty("total_satoshis_sent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_satoshis_sent { get; set; }
    
        /// <summary>*
        /// The total number of satoshis we've received within this channel.</summary>
        [Newtonsoft.Json.JsonProperty("total_satoshis_received", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_satoshis_received { get; set; }
    
        /// <summary>*
        /// The total number of updates conducted within this channel.</summary>
        [Newtonsoft.Json.JsonProperty("num_updates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Num_updates { get; set; }
    
        /// <summary>*
        /// The list of active, uncleared HTLCs currently pending within the channel.</summary>
        [Newtonsoft.Json.JsonProperty("pending_htlcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcHTLC> Pending_htlcs { get; set; }
    
        /// <summary>*
        /// The CSV delay expressed in relative blocks. If the channel is force closed,
        /// we will need to wait for this many blocks before we can regain our funds.</summary>
        [Newtonsoft.Json.JsonProperty("csv_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Csv_delay { get; set; }
    
        /// <summary>/ Whether this channel is advertised to the network or not.</summary>
        [Newtonsoft.Json.JsonProperty("private", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Private { get; set; }
    
        /// <summary>/ True if we were the ones that created the channel.</summary>
        [Newtonsoft.Json.JsonProperty("initiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Initiator { get; set; }
    
        /// <summary>/ A set of flags showing the current state of the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_status_flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_status_flags { get; set; }
    
        /// <summary>/ The minimum satoshis this node is required to reserve in its balance.</summary>
        [Newtonsoft.Json.JsonProperty("local_chan_reserve_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_chan_reserve_sat { get; set; }
    
        /// <summary>*
        /// The minimum satoshis the other node is required to reserve in its balance.</summary>
        [Newtonsoft.Json.JsonProperty("remote_chan_reserve_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_chan_reserve_sat { get; set; }
    
        /// <summary>/ Deprecated. Use commitment_type.</summary>
        [Newtonsoft.Json.JsonProperty("static_remote_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Static_remote_key { get; set; }
    
        /// <summary>/ The commitment type used by this channel.</summary>
        [Newtonsoft.Json.JsonProperty("commitment_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcCommitmentType? Commitment_type { get; set; }
    
        /// <summary>*
        /// The number of seconds that the channel has been monitored by the channel
        /// scoring system. Scores are currently not persisted, so this value may be
        /// less than the lifetime of the channel [EXPERIMENTAL].</summary>
        [Newtonsoft.Json.JsonProperty("lifetime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Lifetime { get; set; }
    
        /// <summary>*
        /// The number of seconds that the remote peer has been observed as being online
        /// by the channel scoring system over the lifetime of the channel
        /// [EXPERIMENTAL].</summary>
        [Newtonsoft.Json.JsonProperty("uptime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uptime { get; set; }
    
        /// <summary>*
        /// Close address is the address that we will enforce payout to on cooperative
        /// close if the channel was opened utilizing option upfront shutdown. This
        /// value can be set on channel open by setting close_address in an open channel
        /// request. If this value is not set, you can still choose a payout address by
        /// cooperatively closing with the delivery_address field set.</summary>
        [Newtonsoft.Json.JsonProperty("close_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Close_address { get; set; }
    
        /// <summary>The amount that the initiator of the channel optionally pushed to the remote
        /// party on channel open. This amount will be zero if the channel initiator did
        /// not push any funds to the remote peer. If the initiator field is true, we
        /// pushed this amount to our peer, if it is false, the remote peer pushed this
        /// amount to us.</summary>
        [Newtonsoft.Json.JsonProperty("push_amount_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Push_amount_sat { get; set; }
    
        /// <summary>*
        /// This uint32 indicates if this channel is to be considered 'frozen'. A
        /// frozen channel doest not allow a cooperative channel close by the
        /// initiator. The thaw_height is the height that this restriction stops
        /// applying to the channel. This field is optional, not setting it or using a
        /// value of zero will mean the channel has no additional restrictions.</summary>
        [Newtonsoft.Json.JsonProperty("thaw_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Thaw_height { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelAcceptRequest 
    {
        /// <summary>/ The pubkey of the node that wishes to open an inbound channel.</summary>
        [Newtonsoft.Json.JsonProperty("node_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Node_pubkey { get; set; }
    
        /// <summary>/ The hash of the genesis block that the proposed channel resides in.</summary>
        [Newtonsoft.Json.JsonProperty("chain_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Chain_hash { get; set; }
    
        /// <summary>/ The pending channel id.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
        /// <summary>/ The funding amount in satoshis that initiator wishes to use in the
        /// / channel.</summary>
        [Newtonsoft.Json.JsonProperty("funding_amt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Funding_amt { get; set; }
    
        /// <summary>/ The push amount of the proposed channel in millisatoshis.</summary>
        [Newtonsoft.Json.JsonProperty("push_amt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Push_amt { get; set; }
    
        /// <summary>/ The dust limit of the initiator's commitment tx.</summary>
        [Newtonsoft.Json.JsonProperty("dust_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dust_limit { get; set; }
    
        /// <summary>/ The maximum amount of coins in millisatoshis that can be pending in this
        /// / channel.</summary>
        [Newtonsoft.Json.JsonProperty("max_value_in_flight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Max_value_in_flight { get; set; }
    
        /// <summary>/ The minimum amount of satoshis the initiator requires us to have at all
        /// / times.</summary>
        [Newtonsoft.Json.JsonProperty("channel_reserve", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_reserve { get; set; }
    
        /// <summary>/ The smallest HTLC in millisatoshis that the initiator will accept.</summary>
        [Newtonsoft.Json.JsonProperty("min_htlc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_htlc { get; set; }
    
        /// <summary>/ The initial fee rate that the initiator suggests for both commitment
        /// / transactions.</summary>
        [Newtonsoft.Json.JsonProperty("fee_per_kw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_per_kw { get; set; }
    
        /// <summary>*
        /// The number of blocks to use for the relative time lock in the pay-to-self
        /// output of both commitment transactions.</summary>
        [Newtonsoft.Json.JsonProperty("csv_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Csv_delay { get; set; }
    
        /// <summary>/ The total number of incoming HTLC's that the initiator will accept.</summary>
        [Newtonsoft.Json.JsonProperty("max_accepted_htlcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_accepted_htlcs { get; set; }
    
        /// <summary>/ A bit-field which the initiator uses to specify proposed channel
        /// / behavior.</summary>
        [Newtonsoft.Json.JsonProperty("channel_flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Channel_flags { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelBackup 
    {
        /// <summary>*
        /// Identifies the channel that this backup belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Chan_point { get; set; }
    
        /// <summary>*
        /// Is an encrypted single-chan backup. this can be passed to
        /// RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
        /// order to trigger the recovery protocol. When using REST, this field must be
        /// encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("chan_backup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Chan_backup { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelBackups 
    {
        /// <summary>*
        /// A set of single-chan static channel backups.</summary>
        [Newtonsoft.Json.JsonProperty("chan_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelBackup> Chan_backups { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelBalanceResponse 
    {
        [Newtonsoft.Json.JsonProperty("balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_open_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pending_open_balance { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelCloseSummary 
    {
        /// <summary>/ The outpoint (txid:index) of the funding transaction.</summary>
        [Newtonsoft.Json.JsonProperty("channel_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_point { get; set; }
    
        /// <summary>/  The unique channel ID for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        /// <summary>/ The hash of the genesis block that this channel resides within.</summary>
        [Newtonsoft.Json.JsonProperty("chain_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chain_hash { get; set; }
    
        /// <summary>/ The txid of the transaction which ultimately closed this channel.</summary>
        [Newtonsoft.Json.JsonProperty("closing_tx_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Closing_tx_hash { get; set; }
    
        /// <summary>/ Public key of the remote peer that we formerly had a channel with.</summary>
        [Newtonsoft.Json.JsonProperty("remote_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Remote_pubkey { get; set; }
    
        /// <summary>/ Total capacity of the channel.</summary>
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        /// <summary>/ Height at which the funding transaction was spent.</summary>
        [Newtonsoft.Json.JsonProperty("close_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Close_height { get; set; }
    
        [Newtonsoft.Json.JsonProperty("settled_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Settled_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("time_locked_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Time_locked_balance { get; set; }
    
        /// <summary>/ Details on how the channel was closed.</summary>
        [Newtonsoft.Json.JsonProperty("close_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ChannelCloseSummaryClosureType? Close_type { get; set; }
    
        /// <summary>*
        /// Open initiator is the party that initiated opening the channel. Note that
        /// this value may be unknown if the channel was closed before we migrated to
        /// store open channel information after close.</summary>
        [Newtonsoft.Json.JsonProperty("open_initiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcInitiator? Open_initiator { get; set; }
    
        /// <summary>*
        /// Close initiator indicates which party initiated the close. This value will
        /// be unknown for channels that were cooperatively closed before we started
        /// tracking cooperative close initiators. Note that this indicates which party
        /// initiated a close, and it is possible for both to initiate cooperative or
        /// force closes, although only one party's close will be confirmed on chain.</summary>
        [Newtonsoft.Json.JsonProperty("close_initiator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcInitiator? Close_initiator { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelCloseUpdate 
    {
        [Newtonsoft.Json.JsonProperty("closing_txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Closing_txid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Success { get; set; }
    
    
    }
    
    /// <summary>*
    /// A fully authenticated channel along with all its unique attributes.
    /// Once an authenticated channel announcement has been processed on the network,
    /// then an instance of ChannelEdgeInfo encapsulating the channels attributes is
    /// stored. The other portions relevant to routing policy of a channel are stored
    /// within a ChannelEdgePolicy for each direction of the channel.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelEdge 
    {
        /// <summary>*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("channel_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_point { get; set; }
    
        [Newtonsoft.Json.JsonProperty("last_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update { get; set; }
    
        [Newtonsoft.Json.JsonProperty("node1_pub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node1_pub { get; set; }
    
        [Newtonsoft.Json.JsonProperty("node2_pub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node2_pub { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("node1_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoutingPolicy Node1_policy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("node2_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoutingPolicy Node2_policy { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelEdgeUpdate 
    {
        /// <summary>*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Chan_point { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("routing_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoutingPolicy Routing_policy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("advertising_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Advertising_node { get; set; }
    
        [Newtonsoft.Json.JsonProperty("connecting_node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Connecting_node { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelEventUpdate 
    {
        [Newtonsoft.Json.JsonProperty("open_channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannel Open_channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("closed_channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelCloseSummary Closed_channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("active_channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Active_channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("inactive_channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Inactive_channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_open_channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcPendingUpdate Pending_open_channel { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ChannelEventUpdateUpdateType? Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelFeeReport 
    {
        /// <summary>/ The short channel id that this fee report belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        /// <summary>/ The channel that this fee report belongs to.</summary>
        [Newtonsoft.Json.JsonProperty("channel_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_point { get; set; }
    
        /// <summary>/ The base fee charged regardless of the number of milli-satoshis sent.</summary>
        [Newtonsoft.Json.JsonProperty("base_fee_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base_fee_msat { get; set; }
    
        /// <summary>/ The amount charged per milli-satoshis transferred expressed in
        /// / millionths of a satoshi.</summary>
        [Newtonsoft.Json.JsonProperty("fee_per_mil", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_per_mil { get; set; }
    
        /// <summary>/ The effective fee rate in milli-satoshis. Computed by dividing the
        /// / fee_per_mil value by 1 million.</summary>
        [Newtonsoft.Json.JsonProperty("fee_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Fee_rate { get; set; }
    
    
    }
    
    /// <summary>/ Returns a new instance of the directed channel graph.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelGraph 
    {
        [Newtonsoft.Json.JsonProperty("nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcLightningNode> Nodes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("edges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelEdge> Edges { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelOpenUpdate 
    {
        [Newtonsoft.Json.JsonProperty("channel_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Channel_point { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelPoint 
    {
        /// <summary>*
        /// Txid of the funding transaction. When using REST, this field must be
        /// encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("funding_txid_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Funding_txid_bytes { get; set; }
    
        /// <summary>*
        /// Hex-encoded string representing the byte-reversed hash of the funding
        /// transaction.</summary>
        [Newtonsoft.Json.JsonProperty("funding_txid_str", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Funding_txid_str { get; set; }
    
        [Newtonsoft.Json.JsonProperty("output_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Output_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcChannelUpdate 
    {
        /// <summary>*
        /// The signature that validates the announced data and proves the ownership
        /// of node id.</summary>
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Signature { get; set; }
    
        /// <summary>*
        /// The target chain that this channel was opened within. This value
        /// should be the genesis hash of the target chain. Along with the short
        /// channel ID, this uniquely identifies the channel globally in a
        /// blockchain.</summary>
        [Newtonsoft.Json.JsonProperty("chain_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Chain_hash { get; set; }
    
        /// <summary>*
        /// The unique description of the funding transaction.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        /// <summary>*
        /// A timestamp that allows ordering in the case of multiple announcements.
        /// We should ignore the message if timestamp is not greater than the
        /// last-received.</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Timestamp { get; set; }
    
        /// <summary>*
        /// The bitfield that describes whether optional fields are present in this
        /// update. Currently, the least-significant bit must be set to 1 if the
        /// optional field MaxHtlc is present.</summary>
        [Newtonsoft.Json.JsonProperty("message_flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Message_flags { get; set; }
    
        /// <summary>*
        /// The bitfield that describes additional meta-data concerning how the
        /// update is to be interpreted. Currently, the least-significant bit must be
        /// set to 0 if the creating node corresponds to the first node in the
        /// previously sent channel announcement and 1 otherwise. If the second bit
        /// is set, then the channel is set to be disabled.</summary>
        [Newtonsoft.Json.JsonProperty("channel_flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Channel_flags { get; set; }
    
        /// <summary>*
        /// The minimum number of blocks this node requires to be added to the expiry
        /// of HTLCs. This is a security parameter determined by the node operator.
        /// This value represents the required gap between the time locks of the
        /// incoming and outgoing HTLC's set to this node.</summary>
        [Newtonsoft.Json.JsonProperty("time_lock_delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Time_lock_delta { get; set; }
    
        /// <summary>*
        /// The minimum HTLC value which will be accepted.</summary>
        [Newtonsoft.Json.JsonProperty("htlc_minimum_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Htlc_minimum_msat { get; set; }
    
        /// <summary>*
        /// The base fee that must be used for incoming HTLC's to this particular
        /// channel. This value will be tacked onto the required for a payment
        /// independent of the size of the payment.</summary>
        [Newtonsoft.Json.JsonProperty("base_fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Base_fee { get; set; }
    
        /// <summary>*
        /// The fee rate that will be charged per millionth of a satoshi.</summary>
        [Newtonsoft.Json.JsonProperty("fee_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Fee_rate { get; set; }
    
        /// <summary>*
        /// The maximum HTLC value which will be accepted.</summary>
        [Newtonsoft.Json.JsonProperty("htlc_maximum_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Htlc_maximum_msat { get; set; }
    
        /// <summary>*
        /// The set of data that was appended to this message, some of which we may
        /// not actually know how to iterate or parse. By holding onto this data, we
        /// ensure that we're able to properly validate the set of signatures that
        /// cover these new fields, and ensure we're able to make upgrades to the
        /// network in a forwards compatible manner.</summary>
        [Newtonsoft.Json.JsonProperty("extra_opaque_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Extra_opaque_data { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcCloseStatusUpdate 
    {
        [Newtonsoft.Json.JsonProperty("close_pending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcPendingUpdate Close_pending { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chan_close", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelCloseUpdate Chan_close { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcClosedChannelUpdate 
    {
        /// <summary>*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("closed_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Closed_height { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Chan_point { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcClosedChannelsResponse 
    {
        [Newtonsoft.Json.JsonProperty("channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelCloseSummary> Channels { get; set; }
    
    
    }
    
    /// <summary> - LEGACY: *
    /// A channel using the legacy commitment format having tweaked to_remote
    /// keys.
    ///  - STATIC_REMOTE_KEY: *
    /// A channel that uses the modern commitment format where the key in the
    /// output of the remote party does not change each state. This makes back
    /// up and recovery easier as when the channel is closed, the funds go
    /// directly to that key.
    ///  - ANCHORS: *
    /// A channel that uses a commitment format that has anchor outputs on the
    /// commitments, allowing fee bumping after a force close transaction has
    /// been broadcast.
    ///  - UNKNOWN_COMMITMENT_TYPE: *
    /// Returned when the commitment type isn't known or unavailable.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcCommitmentType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LEGACY")]
        LEGACY = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC_REMOTE_KEY")]
        STATIC_REMOTE_KEY = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ANCHORS")]
        ANCHORS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN_COMMITMENT_TYPE")]
        UNKNOWN_COMMITMENT_TYPE = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcConnectPeerRequest 
    {
        [Newtonsoft.Json.JsonProperty("addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcLightningAddress Addr { get; set; }
    
        /// <summary>* If set, the daemon will attempt to persistently connect to the target
        /// peer. Otherwise, the call will be synchronous.</summary>
        [Newtonsoft.Json.JsonProperty("perm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Perm { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcConnectPeerResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcDebugLevelResponse 
    {
        [Newtonsoft.Json.JsonProperty("sub_systems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sub_systems { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcDeleteAllPaymentsResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcDisconnectPeerResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcEdgeLocator 
    {
        /// <summary>/ The short channel id of this edge.</summary>
        [Newtonsoft.Json.JsonProperty("channel_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel_id { get; set; }
    
        /// <summary>*
        /// The direction of this edge. If direction_reverse is false, the direction
        /// of this edge is from the channel endpoint with the lexicographically smaller
        /// pub key to the endpoint with the larger pub key. If direction_reverse is
        /// is true, the edge goes the other way.</summary>
        [Newtonsoft.Json.JsonProperty("direction_reverse", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Direction_reverse { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcEstimateFeeResponse 
    {
        /// <summary>/ The total fee in satoshis.</summary>
        [Newtonsoft.Json.JsonProperty("fee_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_sat { get; set; }
    
        /// <summary>/ The fee rate in satoshi/byte.</summary>
        [Newtonsoft.Json.JsonProperty("feerate_sat_per_byte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Feerate_sat_per_byte { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFailure 
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FailureFailureCode? Code { get; set; }
    
        /// <summary>/ An optional channel update message.</summary>
        [Newtonsoft.Json.JsonProperty("channel_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelUpdate Channel_update { get; set; }
    
        /// <summary>/ A failure type-dependent htlc value.</summary>
        [Newtonsoft.Json.JsonProperty("htlc_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Htlc_msat { get; set; }
    
        /// <summary>/ The sha256 sum of the onion payload.</summary>
        [Newtonsoft.Json.JsonProperty("onion_sha_256", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Onion_sha_256 { get; set; }
    
        /// <summary>/ A failure type-dependent cltv expiry value.</summary>
        [Newtonsoft.Json.JsonProperty("cltv_expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cltv_expiry { get; set; }
    
        /// <summary>/ A failure type-dependent flags value.</summary>
        [Newtonsoft.Json.JsonProperty("flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Flags { get; set; }
    
        /// <summary>*
        /// The position in the path of the intermediate or final node that generated
        /// the failure message. Position zero is the sender node.</summary>
        [Newtonsoft.Json.JsonProperty("failure_source_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Failure_source_index { get; set; }
    
        /// <summary>/ A failure type-dependent block height.</summary>
        [Newtonsoft.Json.JsonProperty("height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Height { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFeature 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("is_required", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_required { get; set; }
    
        [Newtonsoft.Json.JsonProperty("is_known", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_known { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcFeatureBit
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DATALOSS_PROTECT_REQ")]
        DATALOSS_PROTECT_REQ = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATALOSS_PROTECT_OPT")]
        DATALOSS_PROTECT_OPT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIAL_ROUING_SYNC")]
        INITIAL_ROUING_SYNC = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPFRONT_SHUTDOWN_SCRIPT_REQ")]
        UPFRONT_SHUTDOWN_SCRIPT_REQ = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPFRONT_SHUTDOWN_SCRIPT_OPT")]
        UPFRONT_SHUTDOWN_SCRIPT_OPT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOSSIP_QUERIES_REQ")]
        GOSSIP_QUERIES_REQ = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOSSIP_QUERIES_OPT")]
        GOSSIP_QUERIES_OPT = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLV_ONION_REQ")]
        TLV_ONION_REQ = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLV_ONION_OPT")]
        TLV_ONION_OPT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXT_GOSSIP_QUERIES_REQ")]
        EXT_GOSSIP_QUERIES_REQ = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXT_GOSSIP_QUERIES_OPT")]
        EXT_GOSSIP_QUERIES_OPT = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC_REMOTE_KEY_REQ")]
        STATIC_REMOTE_KEY_REQ = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC_REMOTE_KEY_OPT")]
        STATIC_REMOTE_KEY_OPT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_ADDR_REQ")]
        PAYMENT_ADDR_REQ = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_ADDR_OPT")]
        PAYMENT_ADDR_OPT = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPP_REQ")]
        MPP_REQ = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPP_OPT")]
        MPP_OPT = 16,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFeeLimit 
    {
        /// <summary>*
        /// The fee limit expressed as a fixed amount of satoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("fixed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fixed { get; set; }
    
        /// <summary>*
        /// The fee limit expressed as a fixed amount of millisatoshis.
        /// 
        /// The fields fixed and fixed_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("fixed_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fixed_msat { get; set; }
    
        /// <summary>/ The fee limit expressed as a percentage of the payment amount.</summary>
        [Newtonsoft.Json.JsonProperty("percent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Percent { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFeeReportResponse 
    {
        /// <summary>/ An array of channel fee reports which describes the current fee schedule
        /// / for each channel.</summary>
        [Newtonsoft.Json.JsonProperty("channel_fees", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelFeeReport> Channel_fees { get; set; }
    
        /// <summary>/ The total amount of fee revenue (in satoshis) the switch has collected
        /// / over the past 24 hrs.</summary>
        [Newtonsoft.Json.JsonProperty("day_fee_sum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Day_fee_sum { get; set; }
    
        /// <summary>/ The total amount of fee revenue (in satoshis) the switch has collected
        /// / over the past 1 week.</summary>
        [Newtonsoft.Json.JsonProperty("week_fee_sum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Week_fee_sum { get; set; }
    
        /// <summary>/ The total amount of fee revenue (in satoshis) the switch has collected
        /// / over the past 1 month.</summary>
        [Newtonsoft.Json.JsonProperty("month_fee_sum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Month_fee_sum { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFloatMetric 
    {
        /// <summary>/ Arbitrary float value.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Value { get; set; }
    
        /// <summary>/ The value normalized to [0,1] or [-1,1].</summary>
        [Newtonsoft.Json.JsonProperty("normalized_value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Normalized_value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcForwardingEvent 
    {
        /// <summary>/ Timestamp is the time (unix epoch offset) that this circuit was
        /// / completed.</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timestamp { get; set; }
    
        /// <summary>/ The incoming channel ID that carried the HTLC that created the circuit.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id_in { get; set; }
    
        /// <summary>/ The outgoing channel ID that carried the preimage that completed the
        /// / circuit.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id_out { get; set; }
    
        /// <summary>/ The total amount (in satoshis) of the incoming HTLC that created half
        /// / the circuit.</summary>
        [Newtonsoft.Json.JsonProperty("amt_in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_in { get; set; }
    
        /// <summary>/ The total amount (in satoshis) of the outgoing HTLC that created the
        /// / second half of the circuit.</summary>
        [Newtonsoft.Json.JsonProperty("amt_out", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_out { get; set; }
    
        /// <summary>/ The total fee (in satoshis) that this payment circuit carried.</summary>
        [Newtonsoft.Json.JsonProperty("fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee { get; set; }
    
        /// <summary>/ The total fee (in milli-satoshis) that this payment circuit carried.</summary>
        [Newtonsoft.Json.JsonProperty("fee_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_msat { get; set; }
    
        /// <summary>/ The total amount (in milli-satoshis) of the incoming HTLC that created
        /// / half the circuit.</summary>
        [Newtonsoft.Json.JsonProperty("amt_in_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_in_msat { get; set; }
    
        /// <summary>/ The total amount (in milli-satoshis) of the outgoing HTLC that created
        /// / the second half of the circuit.</summary>
        [Newtonsoft.Json.JsonProperty("amt_out_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_out_msat { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcForwardingHistoryRequest 
    {
        /// <summary>/ Start time is the starting point of the forwarding history request. All
        /// / records beyond this point will be included, respecting the end time, and
        /// / the index offset.</summary>
        [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Start_time { get; set; }
    
        /// <summary>/ End time is the end point of the forwarding history request. The
        /// / response will carry at most 50k records between the start time and the
        /// / end time. The index offset can be used to implement pagination.</summary>
        [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string End_time { get; set; }
    
        /// <summary>/ Index offset is the offset in the time series to start at. As each
        /// / response can only contain 50k records, callers can use this to skip
        /// / around within a packed time series.</summary>
        [Newtonsoft.Json.JsonProperty("index_offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Index_offset { get; set; }
    
        /// <summary>/ The max number of events to return in the response to this query.</summary>
        [Newtonsoft.Json.JsonProperty("num_max_events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_max_events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcForwardingHistoryResponse 
    {
        /// <summary>/ A list of forwarding events from the time slice of the time series
        /// / specified in the request.</summary>
        [Newtonsoft.Json.JsonProperty("forwarding_events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcForwardingEvent> Forwarding_events { get; set; }
    
        /// <summary>/ The index of the last time in the set of returned forwarding events. Can
        /// / be used to seek further, pagination style.</summary>
        [Newtonsoft.Json.JsonProperty("last_offset_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_offset_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFundingPsbtFinalize 
    {
        /// <summary>*
        /// The funded PSBT that contains all witness data to send the exact channel
        /// capacity amount to the PK script returned in the open channel message in a
        /// previous step.</summary>
        [Newtonsoft.Json.JsonProperty("signed_psbt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Signed_psbt { get; set; }
    
        /// <summary>/ The pending channel ID of the channel to get the PSBT for.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFundingPsbtVerify 
    {
        /// <summary>*
        /// The funded but not yet signed PSBT that sends the exact channel capacity
        /// amount to the PK script returned in the open channel message in a previous
        /// step.</summary>
        [Newtonsoft.Json.JsonProperty("funded_psbt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Funded_psbt { get; set; }
    
        /// <summary>/ The pending channel ID of the channel to get the PSBT for.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFundingShim 
    {
        /// <summary>*
        /// A channel shim where the channel point was fully constructed outside
        /// of lnd's wallet and the transaction might already be published.</summary>
        [Newtonsoft.Json.JsonProperty("chan_point_shim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChanPointShim Chan_point_shim { get; set; }
    
        /// <summary>*
        /// A channel shim that uses a PSBT to fund and sign the channel funding
        /// transaction.</summary>
        [Newtonsoft.Json.JsonProperty("psbt_shim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcPsbtShim Psbt_shim { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFundingShimCancel 
    {
        /// <summary>/ The pending channel ID of the channel to cancel the funding shim for.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcFundingStateStepResp 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcGenSeedResponse 
    {
        /// <summary>*
        /// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
        /// cipher seed obtained by the user. This field is optional, as if not
        /// provided, then the daemon will generate a new cipher seed for the user.
        /// Otherwise, then the daemon will attempt to recover the wallet state linked
        /// to this cipher seed.</summary>
        [Newtonsoft.Json.JsonProperty("cipher_seed_mnemonic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Cipher_seed_mnemonic { get; set; }
    
        /// <summary>*
        /// enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
        /// cipher text before run through our mnemonic encoding scheme.</summary>
        [Newtonsoft.Json.JsonProperty("enciphered_seed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Enciphered_seed { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcGetInfoResponse 
    {
        /// <summary>/ The version of the LND software that the node is running.</summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }
    
        /// <summary>/ The SHA1 commit hash that the daemon is compiled with.</summary>
        [Newtonsoft.Json.JsonProperty("commit_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Commit_hash { get; set; }
    
        /// <summary>/ The identity pubkey of the current node.</summary>
        [Newtonsoft.Json.JsonProperty("identity_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identity_pubkey { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }
    
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Color { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_pending_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_pending_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_active_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_active_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_inactive_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_inactive_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_peers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_peers { get; set; }
    
        [Newtonsoft.Json.JsonProperty("block_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Block_height { get; set; }
    
        [Newtonsoft.Json.JsonProperty("block_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Block_hash { get; set; }
    
        [Newtonsoft.Json.JsonProperty("best_header_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Best_header_timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("synced_to_chain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Synced_to_chain { get; set; }
    
        /// <summary>Whether we consider ourselves synced with the public channel graph.</summary>
        [Newtonsoft.Json.JsonProperty("synced_to_graph", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Synced_to_graph { get; set; }
    
        [Newtonsoft.Json.JsonProperty("testnet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Testnet { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chains", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChain> Chains { get; set; }
    
        /// <summary>/ The URIs of the current node.</summary>
        [Newtonsoft.Json.JsonProperty("uris", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Uris { get; set; }
    
        /// <summary>Features that our node has advertised in our init message, node
        /// announcements and invoices.</summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFeature> Features { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcGraphTopologyUpdate 
    {
        [Newtonsoft.Json.JsonProperty("node_updates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcNodeUpdate> Node_updates { get; set; }
    
        [Newtonsoft.Json.JsonProperty("channel_updates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelEdgeUpdate> Channel_updates { get; set; }
    
        [Newtonsoft.Json.JsonProperty("closed_chans", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcClosedChannelUpdate> Closed_chans { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcHTLC 
    {
        [Newtonsoft.Json.JsonProperty("incoming", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Incoming { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("hash_lock", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Hash_lock { get; set; }
    
        [Newtonsoft.Json.JsonProperty("expiration_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Expiration_height { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcHTLCAttempt 
    {
        /// <summary>/ The status of the HTLC.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HTLCAttemptHTLCStatus? Status { get; set; }
    
        /// <summary>/ The route taken by this HTLC.</summary>
        [Newtonsoft.Json.JsonProperty("route", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoute Route { get; set; }
    
        /// <summary>/ The time in UNIX nanoseconds at which this HTLC was sent.</summary>
        [Newtonsoft.Json.JsonProperty("attempt_time_ns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Attempt_time_ns { get; set; }
    
        /// <summary>*
        /// The time in UNIX nanoseconds at which this HTLC was settled or failed.
        /// This value will not be set if the HTLC is still IN_FLIGHT.</summary>
        [Newtonsoft.Json.JsonProperty("resolve_time_ns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resolve_time_ns { get; set; }
    
        /// <summary>Detailed htlc failure info.</summary>
        [Newtonsoft.Json.JsonProperty("failure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcFailure Failure { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcHop 
    {
        /// <summary>*
        /// The unique channel ID for the channel. The first 3 bytes are the block
        /// height, the next 3 the index within the block, and the last 2 bytes are the
        /// output index for the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("chan_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amt_to_forward", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_to_forward { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee { get; set; }
    
        [Newtonsoft.Json.JsonProperty("expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Expiry { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amt_to_forward_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_to_forward_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_msat { get; set; }
    
        /// <summary>*
        /// An optional public key of the hop. If the public key is given, the payment
        /// can be executed without relying on a copy of the channel graph.</summary>
        [Newtonsoft.Json.JsonProperty("pub_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pub_key { get; set; }
    
        /// <summary>*
        /// If set to true, then this hop will be encoded using the new variable length
        /// TLV format. Note that if any custom tlv_records below are specified, then
        /// this field MUST be set to true for them to be encoded properly.</summary>
        [Newtonsoft.Json.JsonProperty("tlv_payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tlv_payload { get; set; }
    
        /// <summary>*
        /// An optional TLV record tha singals the use of an MPP payment. If present,
        /// the receiver will enforce that that the same mpp_record is included in the
        /// final hop payload of all non-zero payments in the HTLC set. If empty, a
        /// regular single-shot payment is or was attempted.</summary>
        [Newtonsoft.Json.JsonProperty("mpp_record", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcMPPRecord Mpp_record { get; set; }
    
        /// <summary>*
        /// An optional set of key-value TLV records. This is useful within the context
        /// of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
        /// to drop off at each hop within the onion.</summary>
        [Newtonsoft.Json.JsonProperty("custom_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, byte[]> Custom_records { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcHopHint 
    {
        /// <summary>/ The public key of the node at the start of the channel.</summary>
        [Newtonsoft.Json.JsonProperty("node_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_id { get; set; }
    
        /// <summary>/ The unique identifier of the channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        /// <summary>/ The base fee of the channel denominated in millisatoshis.</summary>
        [Newtonsoft.Json.JsonProperty("fee_base_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Fee_base_msat { get; set; }
    
        /// <summary>*
        /// The fee rate of the channel for sending one satoshi across it denominated in
        /// millionths of a satoshi.</summary>
        [Newtonsoft.Json.JsonProperty("fee_proportional_millionths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Fee_proportional_millionths { get; set; }
    
        /// <summary>/ The time-lock delta of the channel.</summary>
        [Newtonsoft.Json.JsonProperty("cltv_expiry_delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cltv_expiry_delta { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcInitWalletRequest 
    {
        /// <summary>*
        /// wallet_password is the passphrase that should be used to encrypt the
        /// wallet. This MUST be at least 8 chars in length. After creation, this
        /// password is required to unlock the daemon. When using REST, this field
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("wallet_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Wallet_password { get; set; }
    
        /// <summary>*
        /// cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
        /// cipher seed obtained by the user. This may have been generated by the
        /// GenSeed method, or be an existing seed.</summary>
        [Newtonsoft.Json.JsonProperty("cipher_seed_mnemonic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Cipher_seed_mnemonic { get; set; }
    
        /// <summary>*
        /// aezeed_passphrase is an optional user provided passphrase that will be used
        /// to encrypt the generated aezeed cipher seed. When using REST, this field
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("aezeed_passphrase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Aezeed_passphrase { get; set; }
    
        /// <summary>*
        /// recovery_window is an optional argument specifying the address lookahead
        /// when restoring a wallet seed. The recovery window applies to each
        /// individual branch of the BIP44 derivation paths. Supplying a recovery
        /// window of zero indicates that no addresses should be recovered, such after
        /// the first initialization of the wallet.</summary>
        [Newtonsoft.Json.JsonProperty("recovery_window", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Recovery_window { get; set; }
    
        /// <summary>*
        /// channel_backups is an optional argument that allows clients to recover the
        /// settled funds within a set of channels. This should be populated if the
        /// user was unable to close out all channels and sweep funds before partial or
        /// total data loss occurred. If specified, then after on-chain recovery of
        /// funds, lnd begin to carry out the data loss recovery protocol in order to
        /// recover the funds in each channel from a remote force closed transaction.</summary>
        [Newtonsoft.Json.JsonProperty("channel_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChanBackupSnapshot Channel_backups { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcInitWalletResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcInitiator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INITIATOR_UNKNOWN")]
        INITIATOR_UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIATOR_LOCAL")]
        INITIATOR_LOCAL = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIATOR_REMOTE")]
        INITIATOR_REMOTE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIATOR_BOTH")]
        INITIATOR_BOTH = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcInvoice 
    {
        /// <summary>*
        /// An optional memo to attach along with the invoice. Used for record keeping
        /// purposes for the invoice's creator, and will also be set in the description
        /// field of the encoded payment request if the description_hash field is not
        /// being used.</summary>
        [Newtonsoft.Json.JsonProperty("memo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Memo { get; set; }
    
        /// <summary>*
        /// The hex-encoded preimage (32 byte) which will allow settling an incoming
        /// HTLC payable to this preimage. When using REST, this field must be encoded
        /// as base64.</summary>
        [Newtonsoft.Json.JsonProperty("r_preimage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] R_preimage { get; set; }
    
        /// <summary>*
        /// The hash of the preimage. When using REST, this field must be encoded as
        /// base64.</summary>
        [Newtonsoft.Json.JsonProperty("r_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] R_hash { get; set; }
    
        /// <summary>The fields value and value_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        /// <summary>The fields value and value_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("value_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("settled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Settled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Creation_date { get; set; }
    
        [Newtonsoft.Json.JsonProperty("settle_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Settle_date { get; set; }
    
        /// <summary>*
        /// A bare-bones invoice for a payment within the Lightning Network. With the
        /// details of the invoice, the sender has all the data necessary to send a
        /// payment to the recipient.</summary>
        [Newtonsoft.Json.JsonProperty("payment_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_request { get; set; }
    
        /// <summary>*
        /// Hash (SHA-256) of a description of the payment. Used if the description of
        /// payment (memo) is too long to naturally fit within the description field
        /// of an encoded payment request. When using REST, this field must be encoded
        /// as base64.</summary>
        [Newtonsoft.Json.JsonProperty("description_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Description_hash { get; set; }
    
        /// <summary>/ Payment request expiry time in seconds. Default is 3600 (1 hour).</summary>
        [Newtonsoft.Json.JsonProperty("expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expiry { get; set; }
    
        /// <summary>/ Fallback on-chain address.</summary>
        [Newtonsoft.Json.JsonProperty("fallback_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fallback_addr { get; set; }
    
        /// <summary>/ Delta to use for the time-lock of the CLTV extended to the final hop.</summary>
        [Newtonsoft.Json.JsonProperty("cltv_expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cltv_expiry { get; set; }
    
        /// <summary>*
        /// Route hints that can each be individually used to assist in reaching the
        /// invoice's destination.</summary>
        [Newtonsoft.Json.JsonProperty("route_hints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcRouteHint> Route_hints { get; set; }
    
        /// <summary>/ Whether this invoice should include routing hints for private channels.</summary>
        [Newtonsoft.Json.JsonProperty("private", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Private { get; set; }
    
        /// <summary>*
        /// The "add" index of this invoice. Each newly created invoice will increment
        /// this index making it monotonically increasing. Callers to the
        /// SubscribeInvoices call can use this to instantly get notified of all added
        /// invoices with an add_index greater than this one.</summary>
        [Newtonsoft.Json.JsonProperty("add_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Add_index { get; set; }
    
        /// <summary>*
        /// The "settle" index of this invoice. Each newly settled invoice will
        /// increment this index making it monotonically increasing. Callers to the
        /// SubscribeInvoices call can use this to instantly get notified of all
        /// settled invoices with an settle_index greater than this one.</summary>
        [Newtonsoft.Json.JsonProperty("settle_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Settle_index { get; set; }
    
        /// <summary>/ Deprecated, use amt_paid_sat or amt_paid_msat.</summary>
        [Newtonsoft.Json.JsonProperty("amt_paid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_paid { get; set; }
    
        /// <summary>*
        /// The amount that was accepted for this invoice, in satoshis. This will ONLY
        /// be set if this invoice has been settled. We provide this field as if the
        /// invoice was created with a zero value, then we need to record what amount
        /// was ultimately accepted. Additionally, it's possible that the sender paid
        /// MORE that was specified in the original invoice. So we'll record that here
        /// as well.</summary>
        [Newtonsoft.Json.JsonProperty("amt_paid_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_paid_sat { get; set; }
    
        /// <summary>*
        /// The amount that was accepted for this invoice, in millisatoshis. This will
        /// ONLY be set if this invoice has been settled. We provide this field as if
        /// the invoice was created with a zero value, then we need to record what
        /// amount was ultimately accepted. Additionally, it's possible that the sender
        /// paid MORE that was specified in the original invoice. So we'll record that
        /// here as well.</summary>
        [Newtonsoft.Json.JsonProperty("amt_paid_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_paid_msat { get; set; }
    
        /// <summary>*
        /// The state the invoice is in.</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InvoiceInvoiceState? State { get; set; }
    
        /// <summary>/ List of HTLCs paying to this invoice [EXPERIMENTAL].</summary>
        [Newtonsoft.Json.JsonProperty("htlcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcInvoiceHTLC> Htlcs { get; set; }
    
        /// <summary>/ List of features advertised on the invoice.</summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFeature> Features { get; set; }
    
        /// <summary>*
        /// Indicates if this invoice was a spontaneous payment that arrived via keysend
        /// [EXPERIMENTAL].</summary>
        [Newtonsoft.Json.JsonProperty("is_keysend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Is_keysend { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcInvoiceHTLC 
    {
        /// <summary>/ Short channel id over which the htlc was received.</summary>
        [Newtonsoft.Json.JsonProperty("chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Chan_id { get; set; }
    
        /// <summary>/ Index identifying the htlc on the channel.</summary>
        [Newtonsoft.Json.JsonProperty("htlc_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Htlc_index { get; set; }
    
        /// <summary>/ The amount of the htlc in msat.</summary>
        [Newtonsoft.Json.JsonProperty("amt_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_msat { get; set; }
    
        /// <summary>/ Block height at which this htlc was accepted.</summary>
        [Newtonsoft.Json.JsonProperty("accept_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Accept_height { get; set; }
    
        /// <summary>/ Time at which this htlc was accepted.</summary>
        [Newtonsoft.Json.JsonProperty("accept_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Accept_time { get; set; }
    
        /// <summary>/ Time at which this htlc was settled or canceled.</summary>
        [Newtonsoft.Json.JsonProperty("resolve_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resolve_time { get; set; }
    
        /// <summary>/ Block height at which this htlc expires.</summary>
        [Newtonsoft.Json.JsonProperty("expiry_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Expiry_height { get; set; }
    
        /// <summary>/ Current state the htlc is in.</summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcInvoiceHTLCState? State { get; set; }
    
        /// <summary>/ Custom tlv records.</summary>
        [Newtonsoft.Json.JsonProperty("custom_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, byte[]> Custom_records { get; set; }
    
        /// <summary>/ The total amount of the mpp payment in msat.</summary>
        [Newtonsoft.Json.JsonProperty("mpp_total_amt_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mpp_total_amt_msat { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcInvoiceHTLCState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ACCEPTED")]
        ACCEPTED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SETTLED")]
        SETTLED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANCELED")]
        CANCELED = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcKeyDescriptor 
    {
        /// <summary>*
        /// The raw bytes of the key being identified.</summary>
        [Newtonsoft.Json.JsonProperty("raw_key_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Raw_key_bytes { get; set; }
    
        /// <summary>*
        /// The key locator that identifies which key to use for signing.</summary>
        [Newtonsoft.Json.JsonProperty("key_loc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcKeyLocator Key_loc { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcKeyLocator 
    {
        /// <summary>/ The family of key being identified.</summary>
        [Newtonsoft.Json.JsonProperty("key_family", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_family { get; set; }
    
        /// <summary>/ The precise index of the key being identified.</summary>
        [Newtonsoft.Json.JsonProperty("key_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Key_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcLightningAddress 
    {
        [Newtonsoft.Json.JsonProperty("pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pubkey { get; set; }
    
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }
    
    
    }
    
    /// <summary>*
    /// An individual vertex/node within the channel graph. A node is
    /// connected to other nodes by one or more channel edges emanating from it. As the
    /// graph is directed, a node will also have an incoming edge attached to it for
    /// each outgoing edge.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcLightningNode 
    {
        [Newtonsoft.Json.JsonProperty("last_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pub_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pub_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }
    
        [Newtonsoft.Json.JsonProperty("addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcNodeAddress> Addresses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Color { get; set; }
    
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFeature> Features { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcListChannelsResponse 
    {
        [Newtonsoft.Json.JsonProperty("channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannel> Channels { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcListInvoiceResponse 
    {
        /// <summary>*
        /// A list of invoices from the time slice of the time series specified in the
        /// request.</summary>
        [Newtonsoft.Json.JsonProperty("invoices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcInvoice> Invoices { get; set; }
    
        /// <summary>*
        /// The index of the last item in the set of returned invoices. This can be used
        /// to seek further, pagination style.</summary>
        [Newtonsoft.Json.JsonProperty("last_index_offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_index_offset { get; set; }
    
        /// <summary>*
        /// The index of the last item in the set of returned invoices. This can be used
        /// to seek backwards, pagination style.</summary>
        [Newtonsoft.Json.JsonProperty("first_index_offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string First_index_offset { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcListPaymentsResponse 
    {
        [Newtonsoft.Json.JsonProperty("payments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcPayment> Payments { get; set; }
    
        /// <summary>*
        /// The index of the first item in the set of returned payments. This can be
        /// used as the index_offset to continue seeking backwards in the next request.</summary>
        [Newtonsoft.Json.JsonProperty("first_index_offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string First_index_offset { get; set; }
    
        /// <summary>*
        /// The index of the last item in the set of returned payments. This can be used
        /// as the index_offset to continue seeking forwards in the next request.</summary>
        [Newtonsoft.Json.JsonProperty("last_index_offset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Last_index_offset { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcListPeersResponse 
    {
        [Newtonsoft.Json.JsonProperty("peers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcPeer> Peers { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcListUnspentResponse 
    {
        [Newtonsoft.Json.JsonProperty("utxos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcUtxo> Utxos { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcMPPRecord 
    {
        /// <summary>*
        /// A unique, random identifier used to authenticate the sender as the intended
        /// payer of a multi-path payment. The payment_addr must be the same for all
        /// subpayments, and match the payment_addr provided in the receiver's invoice.
        /// The same payment_addr must be used on all subpayments.</summary>
        [Newtonsoft.Json.JsonProperty("payment_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_addr { get; set; }
    
        /// <summary>*
        /// The total amount in milli-satoshis being sent as part of a larger multi-path
        /// payment. The caller is responsible for ensuring subpayments to the same node
        /// and payment_hash sum exactly to total_amt_msat. The same
        /// total_amt_msat must be used on all subpayments.</summary>
        [Newtonsoft.Json.JsonProperty("total_amt_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_amt_msat { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcMacaroonPermission 
    {
        /// <summary>/ The entity a permission grants access to.</summary>
        [Newtonsoft.Json.JsonProperty("entity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Entity { get; set; }
    
        /// <summary>/ The action that is granted.</summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcMultiChanBackup 
    {
        /// <summary>*
        /// Is the set of all channels that are included in this multi-channel backup.</summary>
        [Newtonsoft.Json.JsonProperty("chan_points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelPoint> Chan_points { get; set; }
    
        /// <summary>*
        /// A single encrypted blob containing all the static channel backups of the
        /// channel listed above. This can be stored as a single file or blob, and
        /// safely be replaced with any prior/future versions. When using REST, this
        /// field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("multi_chan_backup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Multi_chan_backup { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNetworkInfo 
    {
        [Newtonsoft.Json.JsonProperty("graph_diameter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Graph_diameter { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avg_out_degree", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Avg_out_degree { get; set; }
    
        [Newtonsoft.Json.JsonProperty("max_out_degree", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Max_out_degree { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_nodes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("total_network_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_network_capacity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("avg_channel_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Avg_channel_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("min_channel_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_channel_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("max_channel_size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Max_channel_size { get; set; }
    
        [Newtonsoft.Json.JsonProperty("median_channel_size_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Median_channel_size_sat { get; set; }
    
        /// <summary>The number of edges marked as zombies.</summary>
        [Newtonsoft.Json.JsonProperty("num_zombie_chans", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Num_zombie_chans { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNewAddressResponse 
    {
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNodeAddress 
    {
        [Newtonsoft.Json.JsonProperty("network", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Network { get; set; }
    
        [Newtonsoft.Json.JsonProperty("addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Addr { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNodeInfo 
    {
        /// <summary>*
        /// An individual vertex/node within the channel graph. A node is
        /// connected to other nodes by one or more channel edges emanating from it. As
        /// the graph is directed, a node will also have an incoming edge attached to
        /// it for each outgoing edge.</summary>
        [Newtonsoft.Json.JsonProperty("node", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcLightningNode Node { get; set; }
    
        /// <summary>/ The total number of channels for the node.</summary>
        [Newtonsoft.Json.JsonProperty("num_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Num_channels { get; set; }
    
        /// <summary>/ The sum of all channels capacity for the node, denominated in satoshis.</summary>
        [Newtonsoft.Json.JsonProperty("total_capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_capacity { get; set; }
    
        /// <summary>/ A list of all public channels for the node.</summary>
        [Newtonsoft.Json.JsonProperty("channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcChannelEdge> Channels { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcNodeMetricType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BETWEENNESS_CENTRALITY")]
        BETWEENNESS_CENTRALITY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNodeMetricsResponse 
    {
        /// <summary>*
        /// Betweenness centrality is the sum of the ratio of shortest paths that pass
        /// through the node for each pair of nodes in the graph (not counting paths
        /// starting or ending at this node).
        /// Map of node pubkey to betweenness centrality of the node. Normalized
        /// values are in the [0,1] closed interval.</summary>
        [Newtonsoft.Json.JsonProperty("betweenness_centrality", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFloatMetric> Betweenness_centrality { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNodePair 
    {
        /// <summary>*
        /// The sending node of the pair. When using REST, this field must be encoded as
        /// base64.</summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] From { get; set; }
    
        /// <summary>*
        /// The receiving node of the pair. When using REST, this field must be encoded
        /// as base64.</summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] To { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcNodeUpdate 
    {
        [Newtonsoft.Json.JsonProperty("addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Addresses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("identity_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Identity_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("global_features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Global_features { get; set; }
    
        [Newtonsoft.Json.JsonProperty("alias", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Alias { get; set; }
    
        [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Color { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcOpenChannelRequest 
    {
        /// <summary>*
        /// The pubkey of the node to open a channel with. When using REST, this field
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("node_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Node_pubkey { get; set; }
    
        /// <summary>*
        /// The hex encoded pubkey of the node to open a channel with. Deprecated now
        /// that the REST gateway supports base64 encoding of bytes fields.</summary>
        [Newtonsoft.Json.JsonProperty("node_pubkey_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Node_pubkey_string { get; set; }
    
        [Newtonsoft.Json.JsonProperty("local_funding_amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Local_funding_amount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("push_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Push_sat { get; set; }
    
        /// <summary>/ The target number of blocks that the funding transaction should be
        /// / confirmed by.</summary>
        [Newtonsoft.Json.JsonProperty("target_conf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Target_conf { get; set; }
    
        /// <summary>/ A manual fee rate set in sat/byte that should be used when crafting the
        /// / funding transaction.</summary>
        [Newtonsoft.Json.JsonProperty("sat_per_byte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sat_per_byte { get; set; }
    
        /// <summary>/ Whether this channel should be private, not announced to the greater
        /// / network.</summary>
        [Newtonsoft.Json.JsonProperty("private", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Private { get; set; }
    
        /// <summary>/ The minimum value in millisatoshi we will require for incoming HTLCs on
        /// / the channel.</summary>
        [Newtonsoft.Json.JsonProperty("min_htlc_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_htlc_msat { get; set; }
    
        /// <summary>/ The delay we require on the remote's commitment transaction. If this is
        /// / not set, it will be scaled automatically with the channel size.</summary>
        [Newtonsoft.Json.JsonProperty("remote_csv_delay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Remote_csv_delay { get; set; }
    
        /// <summary>/ The minimum number of confirmations each one of your outputs used for
        /// / the funding transaction must satisfy.</summary>
        [Newtonsoft.Json.JsonProperty("min_confs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Min_confs { get; set; }
    
        /// <summary>/ Whether unconfirmed outputs should be used as inputs for the funding
        /// / transaction.</summary>
        [Newtonsoft.Json.JsonProperty("spend_unconfirmed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Spend_unconfirmed { get; set; }
    
        /// <summary>Close address is an optional address which specifies the address to which
        /// funds should be paid out to upon cooperative close. This field may only be
        /// set if the peer supports the option upfront feature bit (call listpeers
        /// to check). The remote peer will only accept cooperative closes to this
        /// address if it is set.
        /// 
        /// Note: If this value is set on channel creation, you will *not* be able to
        /// cooperatively close out to a different address.</summary>
        [Newtonsoft.Json.JsonProperty("close_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Close_address { get; set; }
    
        /// <summary>*
        /// Funding shims are an optional argument that allow the caller to intercept
        /// certain funding functionality. For example, a shim can be provided to use a
        /// particular key for the commitment key (ideally cold) rather than use one
        /// that is generated by the wallet as normal, or signal that signing will be
        /// carried out in an interactive manner (PSBT based).</summary>
        [Newtonsoft.Json.JsonProperty("funding_shim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcFundingShim Funding_shim { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcOpenStatusUpdate 
    {
        /// <summary>*
        /// Signals that the channel is now fully negotiated and the funding
        /// transaction published.</summary>
        [Newtonsoft.Json.JsonProperty("chan_pending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcPendingUpdate Chan_pending { get; set; }
    
        /// <summary>*
        /// Signals that the channel's funding transaction has now reached the
        /// required number of confirmations on chain and can be used.</summary>
        [Newtonsoft.Json.JsonProperty("chan_open", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelOpenUpdate Chan_open { get; set; }
    
        /// <summary>*
        /// Signals that the funding process has been suspended and the construction
        /// of a PSBT that funds the channel PK script is now required.</summary>
        [Newtonsoft.Json.JsonProperty("psbt_fund", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcReadyForPsbtFunding Psbt_fund { get; set; }
    
        /// <summary>*
        /// The pending channel ID of the created channel. This value may be used to
        /// further the funding flow manually via the FundingStateStep method.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcOutPoint 
    {
        /// <summary>/ Raw bytes representing the transaction id.</summary>
        [Newtonsoft.Json.JsonProperty("txid_bytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Txid_bytes { get; set; }
    
        /// <summary>/ Reversed, hex-encoded string representing the transaction id.</summary>
        [Newtonsoft.Json.JsonProperty("txid_str", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Txid_str { get; set; }
    
        /// <summary>/ The index of the output on the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("output_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Output_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPayReq 
    {
        [Newtonsoft.Json.JsonProperty("destination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Destination { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_hash { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_satoshis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Num_satoshis { get; set; }
    
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timestamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expiry { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        [Newtonsoft.Json.JsonProperty("description_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description_hash { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fallback_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fallback_addr { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cltv_expiry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cltv_expiry { get; set; }
    
        [Newtonsoft.Json.JsonProperty("route_hints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcRouteHint> Route_hints { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_addr { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Num_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFeature> Features { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPayment 
    {
        [Newtonsoft.Json.JsonProperty("payment_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_hash { get; set; }
    
        /// <summary>/ Deprecated, use value_sat or value_msat.</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creation_date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Creation_date { get; set; }
    
        /// <summary>/ Deprecated, use fee_sat or fee_msat.</summary>
        [Newtonsoft.Json.JsonProperty("fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_preimage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_preimage { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value_sat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value_msat { get; set; }
    
        /// <summary>/ The optional payment request being fulfilled.</summary>
        [Newtonsoft.Json.JsonProperty("payment_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_request { get; set; }
    
        /// <summary>The status of the payment.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PaymentPaymentStatus? Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_sat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_msat { get; set; }
    
        /// <summary>/ The time in UNIX nanoseconds at which the payment was created.</summary>
        [Newtonsoft.Json.JsonProperty("creation_time_ns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Creation_time_ns { get; set; }
    
        /// <summary>/ The HTLCs made in attempt to settle the payment [EXPERIMENTAL].</summary>
        [Newtonsoft.Json.JsonProperty("htlcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcHTLCAttempt> Htlcs { get; set; }
    
        /// <summary>*
        /// The creation index of this payment. Each payment can be uniquely identified
        /// by this index, which may not strictly increment by 1 for payments made in
        /// older versions of lnd.</summary>
        [Newtonsoft.Json.JsonProperty("payment_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_index { get; set; }
    
        [Newtonsoft.Json.JsonProperty("failure_reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcPaymentFailureReason? Failure_reason { get; set; }
    
    
    }
    
    /// <summary> - FAILURE_REASON_NONE: *
    /// Payment isn't failed (yet).
    ///  - FAILURE_REASON_TIMEOUT: *
    /// There are more routes to try, but the payment timeout was exceeded.
    ///  - FAILURE_REASON_NO_ROUTE: *
    /// All possible routes were tried and failed permanently. Or were no
    /// routes to the destination at all.
    ///  - FAILURE_REASON_ERROR: *
    /// A non-recoverable error has occured.
    ///  - FAILURE_REASON_INCORRECT_PAYMENT_DETAILS: *
    /// Payment details incorrect (unknown hash, invalid amt or
    /// invalid final cltv delta)
    ///  - FAILURE_REASON_INSUFFICIENT_BALANCE: *
    /// Insufficient local balance.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LnrpcPaymentFailureReason
    {
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_NONE")]
        FAILURE_REASON_NONE = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_TIMEOUT")]
        FAILURE_REASON_TIMEOUT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_NO_ROUTE")]
        FAILURE_REASON_NO_ROUTE = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_ERROR")]
        FAILURE_REASON_ERROR = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_INCORRECT_PAYMENT_DETAILS")]
        FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILURE_REASON_INSUFFICIENT_BALANCE")]
        FAILURE_REASON_INSUFFICIENT_BALANCE = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPeer 
    {
        [Newtonsoft.Json.JsonProperty("pub_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pub_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }
    
        [Newtonsoft.Json.JsonProperty("bytes_sent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bytes_sent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("bytes_recv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bytes_recv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sat_sent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sat_sent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sat_recv", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sat_recv { get; set; }
    
        [Newtonsoft.Json.JsonProperty("inbound", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Inbound { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ping_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ping_time { get; set; }
    
        /// <summary>The type of sync we are currently performing with this peer.</summary>
        [Newtonsoft.Json.JsonProperty("sync_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PeerSyncType? Sync_type { get; set; }
    
        /// <summary>/ Features advertised by the remote peer in their init message.</summary>
        [Newtonsoft.Json.JsonProperty("features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LnrpcFeature> Features { get; set; }
    
        /// <summary>The latest errors received from our peer with timestamps, limited to the 10
        /// most recent errors. These errors are tracked across peer connections, but
        /// are not persisted across lnd restarts. Note that these errors are only
        /// stored for peers that we have channels open with, to prevent peers from
        /// spamming us with errors at no cost.</summary>
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcTimestampedError> Errors { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPeerEvent 
    {
        /// <summary>/ The identity pubkey of the peer.</summary>
        [Newtonsoft.Json.JsonProperty("pub_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pub_key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PeerEventEventType? Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPendingChannelsResponse 
    {
        [Newtonsoft.Json.JsonProperty("total_limbo_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_limbo_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_open_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PendingChannelsResponsePendingOpenChannel> Pending_open_channels { get; set; }
    
        /// <summary>Deprecated: Channels pending closing previously contained cooperatively
        /// closed channels with a single confirmation. These channels are now
        /// considered closed from the time we see them on chain.</summary>
        [Newtonsoft.Json.JsonProperty("pending_closing_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PendingChannelsResponseClosedChannel> Pending_closing_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending_force_closing_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PendingChannelsResponseForceClosedChannel> Pending_force_closing_channels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("waiting_close_channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PendingChannelsResponseWaitingCloseChannel> Waiting_close_channels { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPendingHTLC 
    {
        [Newtonsoft.Json.JsonProperty("incoming", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Incoming { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("outpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outpoint { get; set; }
    
        [Newtonsoft.Json.JsonProperty("maturity_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Maturity_height { get; set; }
    
        /// <summary>*
        /// The number of blocks remaining until the current stage can be swept.
        /// Negative values indicate how many blocks have passed since becoming
        /// mature.</summary>
        [Newtonsoft.Json.JsonProperty("blocks_til_maturity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Blocks_til_maturity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("stage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Stage { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPendingUpdate 
    {
        [Newtonsoft.Json.JsonProperty("txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Txid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("output_index", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Output_index { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPolicyUpdateRequest 
    {
        /// <summary>/ If set, then this update applies to all currently active channels.</summary>
        [Newtonsoft.Json.JsonProperty("global", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Global { get; set; }
    
        /// <summary>/ If set, this update will target a specific channel.</summary>
        [Newtonsoft.Json.JsonProperty("chan_point", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelPoint Chan_point { get; set; }
    
        /// <summary>/ The base fee charged regardless of the number of milli-satoshis sent.</summary>
        [Newtonsoft.Json.JsonProperty("base_fee_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Base_fee_msat { get; set; }
    
        /// <summary>/ The effective fee rate in milli-satoshis. The precision of this value
        /// / goes up to 6 decimal places, so 1e-6.</summary>
        [Newtonsoft.Json.JsonProperty("fee_rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Fee_rate { get; set; }
    
        /// <summary>/ The required timelock delta for HTLCs forwarded over the channel.</summary>
        [Newtonsoft.Json.JsonProperty("time_lock_delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Time_lock_delta { get; set; }
    
        /// <summary>/ If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
        /// / HTLC will be unchanged.</summary>
        [Newtonsoft.Json.JsonProperty("max_htlc_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Max_htlc_msat { get; set; }
    
        /// <summary>/ The minimum HTLC size in milli-satoshis. Only applied if
        /// / min_htlc_msat_specified is true.</summary>
        [Newtonsoft.Json.JsonProperty("min_htlc_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_htlc_msat { get; set; }
    
        /// <summary>/ If true, min_htlc_msat is applied.</summary>
        [Newtonsoft.Json.JsonProperty("min_htlc_msat_specified", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Min_htlc_msat_specified { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPolicyUpdateResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcPsbtShim 
    {
        /// <summary>*
        /// A unique identifier of 32 random bytes that will be used as the pending
        /// channel ID to identify the PSBT state machine when interacting with it and
        /// on the wire protocol to initiate the funding request.</summary>
        [Newtonsoft.Json.JsonProperty("pending_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Pending_chan_id { get; set; }
    
        /// <summary>*
        /// An optional base PSBT the new channel output will be added to. If this is
        /// non-empty, it must be a binary serialized PSBT.</summary>
        [Newtonsoft.Json.JsonProperty("base_psbt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Base_psbt { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcQueryRoutesResponse 
    {
        /// <summary>*
        /// The route that results from the path finding operation. This is still a
        /// repeated field to retain backwards compatibility.</summary>
        [Newtonsoft.Json.JsonProperty("routes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcRoute> Routes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("success_prob", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Success_prob { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcReadyForPsbtFunding 
    {
        /// <summary>*
        /// The P2WSH address of the channel funding multisig address that the below
        /// specified amount in satoshis needs to be sent to.</summary>
        [Newtonsoft.Json.JsonProperty("funding_address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Funding_address { get; set; }
    
        /// <summary>*
        /// The exact amount in satoshis that needs to be sent to the above address to
        /// fund the pending channel.</summary>
        [Newtonsoft.Json.JsonProperty("funding_amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Funding_amount { get; set; }
    
        /// <summary>*
        /// A raw PSBT that contains the pending channel output. If a base PSBT was
        /// provided in the PsbtShim, this is the base PSBT with one additional output.
        /// If no base PSBT was specified, this is an otherwise empty PSBT with exactly
        /// one output.</summary>
        [Newtonsoft.Json.JsonProperty("psbt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Psbt { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcRestoreBackupResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcRestoreChanBackupRequest 
    {
        /// <summary>*
        /// The channels to restore as a list of channel/backup pairs.</summary>
        [Newtonsoft.Json.JsonProperty("chan_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChannelBackups Chan_backups { get; set; }
    
        /// <summary>*
        /// The channels to restore in the packed multi backup format. When using
        /// REST, this field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("multi_chan_backup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Multi_chan_backup { get; set; }
    
    
    }
    
    /// <summary>*
    /// A path through the channel graph which runs over one or more channels in
    /// succession. This struct carries all the information required to craft the
    /// Sphinx onion packet, and send the payment along the first hop in the path. A
    /// route is only selected as valid if all the channels have sufficient capacity to
    /// carry the initial payment amount after fees are accounted for.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcRoute 
    {
        /// <summary>*
        /// The cumulative (final) time lock across the entire route. This is the CLTV
        /// value that should be extended to the first hop in the route. All other hops
        /// will decrement the time-lock as advertised, leaving enough time for all
        /// hops to wait for or present the payment preimage to complete the payment.</summary>
        [Newtonsoft.Json.JsonProperty("total_time_lock", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Total_time_lock { get; set; }
    
        /// <summary>*
        /// The sum of the fees paid at each hop within the final route. In the case
        /// of a one-hop payment, this value will be zero as we don't need to pay a fee
        /// to ourselves.</summary>
        [Newtonsoft.Json.JsonProperty("total_fees", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_fees { get; set; }
    
        /// <summary>*
        /// The total amount of funds required to complete a payment over this route.
        /// This value includes the cumulative fees at each hop. As a result, the HTLC
        /// extended to the first-hop in the route will need to have at least this many
        /// satoshis, otherwise the route will fail at an intermediate node due to an
        /// insufficient amount of fees.</summary>
        [Newtonsoft.Json.JsonProperty("total_amt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_amt { get; set; }
    
        /// <summary>*
        /// Contains details concerning the specific forwarding details at each hop.</summary>
        [Newtonsoft.Json.JsonProperty("hops", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcHop> Hops { get; set; }
    
        /// <summary>*
        /// The total fees in millisatoshis.</summary>
        [Newtonsoft.Json.JsonProperty("total_fees_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_fees_msat { get; set; }
    
        /// <summary>*
        /// The total amount in millisatoshis.</summary>
        [Newtonsoft.Json.JsonProperty("total_amt_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_amt_msat { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcRouteHint 
    {
        /// <summary>*
        /// A list of hop hints that when chained together can assist in reaching a
        /// specific destination.</summary>
        [Newtonsoft.Json.JsonProperty("hop_hints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcHopHint> Hop_hints { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcRoutingPolicy 
    {
        [Newtonsoft.Json.JsonProperty("time_lock_delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Time_lock_delta { get; set; }
    
        [Newtonsoft.Json.JsonProperty("min_htlc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Min_htlc { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee_base_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_base_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fee_rate_milli_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fee_rate_milli_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Disabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("max_htlc_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Max_htlc_msat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("last_update", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last_update { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendCoinsRequest 
    {
        [Newtonsoft.Json.JsonProperty("addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Addr { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amount { get; set; }
    
        /// <summary>/ The target number of blocks that this transaction should be confirmed
        /// / by.</summary>
        [Newtonsoft.Json.JsonProperty("target_conf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Target_conf { get; set; }
    
        /// <summary>/ A manual fee rate set in sat/byte that should be used when crafting the
        /// / transaction.</summary>
        [Newtonsoft.Json.JsonProperty("sat_per_byte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sat_per_byte { get; set; }
    
        /// <summary>*
        /// If set, then the amount field will be ignored, and lnd will attempt to
        /// send all the coins under control of the internal wallet to the specified
        /// address.</summary>
        [Newtonsoft.Json.JsonProperty("send_all", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Send_all { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendCoinsResponse 
    {
        [Newtonsoft.Json.JsonProperty("txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Txid { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendManyResponse 
    {
        [Newtonsoft.Json.JsonProperty("txid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Txid { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendRequest 
    {
        /// <summary>*
        /// The identity pubkey of the payment recipient. When using REST, this field
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("dest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Dest { get; set; }
    
        /// <summary>*
        /// The hex-encoded identity pubkey of the payment recipient. Deprecated now
        /// that the REST gateway supports base64 encoding of bytes fields.</summary>
        [Newtonsoft.Json.JsonProperty("dest_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dest_string { get; set; }
    
        /// <summary>*
        /// The amount to send expressed in satoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("amt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt { get; set; }
    
        /// <summary>*
        /// The amount to send expressed in millisatoshis.
        /// 
        /// The fields amt and amt_msat are mutually exclusive.</summary>
        [Newtonsoft.Json.JsonProperty("amt_msat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amt_msat { get; set; }
    
        /// <summary>*
        /// The hash to use within the payment's HTLC. When using REST, this field
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("payment_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_hash { get; set; }
    
        /// <summary>*
        /// The hex-encoded hash to use within the payment's HTLC. Deprecated now
        /// that the REST gateway supports base64 encoding of bytes fields.</summary>
        [Newtonsoft.Json.JsonProperty("payment_hash_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_hash_string { get; set; }
    
        /// <summary>*
        /// A bare-bones invoice for a payment within the Lightning Network. With the
        /// details of the invoice, the sender has all the data necessary to send a
        /// payment to the recipient.</summary>
        [Newtonsoft.Json.JsonProperty("payment_request", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_request { get; set; }
    
        /// <summary>*
        /// The CLTV delta from the current height that should be used to set the
        /// timelock for the final hop.</summary>
        [Newtonsoft.Json.JsonProperty("final_cltv_delta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Final_cltv_delta { get; set; }
    
        /// <summary>*
        /// The maximum number of satoshis that will be paid as a fee of the payment.
        /// This value can be represented either as a percentage of the amount being
        /// sent, or as a fixed amount of the maximum fee the user is willing the pay to
        /// send the payment.</summary>
        [Newtonsoft.Json.JsonProperty("fee_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcFeeLimit Fee_limit { get; set; }
    
        /// <summary>*
        /// The channel id of the channel that must be taken to the first hop. If zero,
        /// any channel may be used.</summary>
        [Newtonsoft.Json.JsonProperty("outgoing_chan_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Outgoing_chan_id { get; set; }
    
        /// <summary>*
        /// The pubkey of the last hop of the route. If empty, any hop may be used.</summary>
        [Newtonsoft.Json.JsonProperty("last_hop_pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Last_hop_pubkey { get; set; }
    
        /// <summary>*
        /// An optional maximum total time lock for the route. This should not exceed
        /// lnd's `--max-cltv-expiry` setting. If zero, then the value of
        /// `--max-cltv-expiry` is enforced.</summary>
        [Newtonsoft.Json.JsonProperty("cltv_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Cltv_limit { get; set; }
    
        /// <summary>*
        /// An optional field that can be used to pass an arbitrary set of TLV records
        /// to a peer which understands the new records. This can be used to pass
        /// application specific data during the payment attempt. Record types are
        /// required to be in the custom range &gt;= 65536. When using REST, the values
        /// must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("dest_custom_records", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, byte[]> Dest_custom_records { get; set; }
    
        /// <summary>/ If set, circular payments to self are permitted.</summary>
        [Newtonsoft.Json.JsonProperty("allow_self_payment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Allow_self_payment { get; set; }
    
        /// <summary>*
        /// Features assumed to be supported by the final node. All transitive feature
        /// dependencies must also be set properly. For a given feature bit pair, either
        /// optional or remote may be set, but not both. If this field is nil or empty,
        /// the router will try to load destination features from the graph as a
        /// fallback.</summary>
        [Newtonsoft.Json.JsonProperty("dest_features", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<LnrpcFeatureBit> Dest_features { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendResponse 
    {
        [Newtonsoft.Json.JsonProperty("payment_error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_preimage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_preimage { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_route", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoute Payment_route { get; set; }
    
        [Newtonsoft.Json.JsonProperty("payment_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_hash { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSendToRouteRequest 
    {
        /// <summary>*
        /// The payment hash to use for the HTLC. When using REST, this field must be
        /// encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("payment_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Payment_hash { get; set; }
    
        /// <summary>*
        /// An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
        /// that the REST gateway supports base64 encoding of bytes fields.</summary>
        [Newtonsoft.Json.JsonProperty("payment_hash_string", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Payment_hash_string { get; set; }
    
        /// <summary>/ Route that should be used to attempt to complete the payment.</summary>
        [Newtonsoft.Json.JsonProperty("route", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcRoute Route { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSignMessageRequest 
    {
        /// <summary>*
        /// The message to be signed. When using REST, this field must be encoded as
        /// base64.</summary>
        [Newtonsoft.Json.JsonProperty("msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Msg { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcSignMessageResponse 
    {
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcStopResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcTimestampedError 
    {
        /// <summary>The unix timestamp in seconds when the error occurred.</summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timestamp { get; set; }
    
        /// <summary>The string representation of the error sent by our peer.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcTransaction 
    {
        [Newtonsoft.Json.JsonProperty("tx_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tx_hash { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("num_confirmations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Num_confirmations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("block_hash", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Block_hash { get; set; }
    
        [Newtonsoft.Json.JsonProperty("block_height", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Block_height { get; set; }
    
        [Newtonsoft.Json.JsonProperty("time_stamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Time_stamp { get; set; }
    
        [Newtonsoft.Json.JsonProperty("total_fees", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_fees { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dest_addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Dest_addresses { get; set; }
    
        /// <summary>/ The raw transaction hex.</summary>
        [Newtonsoft.Json.JsonProperty("raw_tx_hex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Raw_tx_hex { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcTransactionDetails 
    {
        /// <summary>/ The list of transactions relevant to the wallet.</summary>
        [Newtonsoft.Json.JsonProperty("transactions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LnrpcTransaction> Transactions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcUnlockWalletRequest 
    {
        /// <summary>*
        /// wallet_password should be the current valid passphrase for the daemon. This
        /// will be required to decrypt on-disk material that the daemon requires to
        /// function properly. When using REST, this field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("wallet_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Wallet_password { get; set; }
    
        /// <summary>*
        /// recovery_window is an optional argument specifying the address lookahead
        /// when restoring a wallet seed. The recovery window applies to each
        /// individual branch of the BIP44 derivation paths. Supplying a recovery
        /// window of zero indicates that no addresses should be recovered, such after
        /// the first initialization of the wallet.</summary>
        [Newtonsoft.Json.JsonProperty("recovery_window", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Recovery_window { get; set; }
    
        /// <summary>*
        /// channel_backups is an optional argument that allows clients to recover the
        /// settled funds within a set of channels. This should be populated if the
        /// user was unable to close out all channels and sweep funds before partial or
        /// total data loss occurred. If specified, then after on-chain recovery of
        /// funds, lnd begin to carry out the data loss recovery protocol in order to
        /// recover the funds in each channel from a remote force closed transaction.</summary>
        [Newtonsoft.Json.JsonProperty("channel_backups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcChanBackupSnapshot Channel_backups { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcUnlockWalletResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcUtxo 
    {
        [Newtonsoft.Json.JsonProperty("address_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LnrpcAddressType? Address_type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Address { get; set; }
    
        [Newtonsoft.Json.JsonProperty("amount_sat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Amount_sat { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pk_script", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pk_script { get; set; }
    
        [Newtonsoft.Json.JsonProperty("outpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcOutPoint Outpoint { get; set; }
    
        [Newtonsoft.Json.JsonProperty("confirmations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Confirmations { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcVerifyChanBackupResponse 
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcVerifyMessageRequest 
    {
        /// <summary>*
        /// The message over which the signature is to be verified. When using REST,
        /// this field must be encoded as base64.</summary>
        [Newtonsoft.Json.JsonProperty("msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Msg { get; set; }
    
        [Newtonsoft.Json.JsonProperty("signature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Signature { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcVerifyMessageResponse 
    {
        [Newtonsoft.Json.JsonProperty("valid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Valid { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pubkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pubkey { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LnrpcWalletBalanceResponse 
    {
        [Newtonsoft.Json.JsonProperty("total_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Total_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("confirmed_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Confirmed_balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("unconfirmed_balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unconfirmed_balance { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProtobufAny 
    {
        [Newtonsoft.Json.JsonProperty("type_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type_url { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RuntimeStreamError 
    {
        [Newtonsoft.Json.JsonProperty("grpc_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Grpc_code { get; set; }
    
        [Newtonsoft.Json.JsonProperty("http_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Http_code { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("http_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ProtobufAny> Details { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous
    {
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BETWEENNESS_CENTRALITY")]
        BETWEENNESS_CENTRALITY = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Anonymous2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"DATALOSS_PROTECT_REQ")]
        DATALOSS_PROTECT_REQ = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DATALOSS_PROTECT_OPT")]
        DATALOSS_PROTECT_OPT = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"INITIAL_ROUING_SYNC")]
        INITIAL_ROUING_SYNC = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPFRONT_SHUTDOWN_SCRIPT_REQ")]
        UPFRONT_SHUTDOWN_SCRIPT_REQ = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UPFRONT_SHUTDOWN_SCRIPT_OPT")]
        UPFRONT_SHUTDOWN_SCRIPT_OPT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOSSIP_QUERIES_REQ")]
        GOSSIP_QUERIES_REQ = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"GOSSIP_QUERIES_OPT")]
        GOSSIP_QUERIES_OPT = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLV_ONION_REQ")]
        TLV_ONION_REQ = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TLV_ONION_OPT")]
        TLV_ONION_OPT = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXT_GOSSIP_QUERIES_REQ")]
        EXT_GOSSIP_QUERIES_REQ = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EXT_GOSSIP_QUERIES_OPT")]
        EXT_GOSSIP_QUERIES_OPT = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC_REMOTE_KEY_REQ")]
        STATIC_REMOTE_KEY_REQ = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"STATIC_REMOTE_KEY_OPT")]
        STATIC_REMOTE_KEY_OPT = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_ADDR_REQ")]
        PAYMENT_ADDR_REQ = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PAYMENT_ADDR_OPT")]
        PAYMENT_ADDR_OPT = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPP_REQ")]
        MPP_REQ = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MPP_OPT")]
        MPP_OPT = 16,
    
    }
    
    /// <summary>/ The address type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Type
    {
        [System.Runtime.Serialization.EnumMember(Value = @"WITNESS_PUBKEY_HASH")]
        WITNESS_PUBKEY_HASH = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NESTED_PUBKEY_HASH")]
        NESTED_PUBKEY_HASH = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNUSED_WITNESS_PUBKEY_HASH")]
        UNUSED_WITNESS_PUBKEY_HASH = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNUSED_NESTED_PUBKEY_HASH")]
        UNUSED_NESTED_PUBKEY_HASH = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Response 
    {
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcCloseStatusUpdate Result { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RuntimeStreamError Error { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.1.11.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Response2 
    {
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LnrpcInvoice Result { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RuntimeStreamError Error { get; set; }
    
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.4.1.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.4.1.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
